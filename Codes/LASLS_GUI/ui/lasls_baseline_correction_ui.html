<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>LASLS Baseline Correction</title>
<style>
/* ====================================================================
   CSS Variables - MCR-ALS Design System
   ==================================================================== */
:root {
    --bg-primary: #E8EBED; --bg-secondary: #F2F4F6; --bg-tertiary: #EBF0F4;
    --text-primary: #1E293B; --text-secondary: #64748B; --text-tertiary: #94A3B8;
    --border-color: #E2E8F0;
    --accent-primary: #42A5F5; --accent-secondary: #90CAF9;
    --accent-gradient-start: #90CAF9; --accent-gradient-end: #64B5F6;
    --button-bg: #F1F5F9; --button-border: #E2E8F0; --button-text: #475569;
    --shadow-color: rgba(0, 0, 0, 0.05); --shadow-accent: rgba(100, 181, 246, 0.3);
    --status-indicator: #10B981; --error-color: #EF4444; --warning-color: #F59E0B;
    --spectrum-color: rgba(66, 165, 245, 1.0);
    --baseline-color: rgba(239, 68, 68, 0.9);
    --corrected-color: rgba(16, 185, 129, 0.9);
    --interval-fill: rgba(66, 165, 245, 0.12);
    --interval-border: rgba(66, 165, 245, 0.4);
    --interval-selected-fill: rgba(239, 68, 68, 0.14);
    --interval-selected-border: rgba(239, 68, 68, 0.7);
    --mean-spectrum-color: rgba(80, 80, 80, 1.0);
    --all-spectra-color: rgba(160, 160, 160, 0.4);
    --peak-color: rgba(245, 158, 11, 0.9);
    --grid-color: rgba(0, 0, 0, 0.08);
    --axis-text: #64748B;
}
body.dark-mode {
    --bg-primary: #0F172A; --bg-secondary: #1E293B; --bg-tertiary: #334155;
    --text-primary: #F1F5F9; --text-secondary: #CBD5E1; --text-tertiary: #94A3B8;
    --border-color: #334155;
    --accent-primary: #60A5FA; --accent-secondary: #93C5FD;
    --accent-gradient-start: #60A5FA; --accent-gradient-end: #3B82F6;
    --button-bg: #334155; --button-border: #475569; --button-text: #E2E8F0;
    --shadow-color: rgba(0, 0, 0, 0.3); --shadow-accent: rgba(59, 130, 246, 0.4);
    --status-indicator: #34D399; --error-color: #F87171; --warning-color: #FBBF24;
    --spectrum-color: rgba(96, 165, 250, 1.0);
    --baseline-color: rgba(248, 113, 113, 0.9);
    --corrected-color: rgba(52, 211, 153, 0.9);
    --interval-fill: rgba(96, 165, 250, 0.12);
    --interval-border: rgba(96, 165, 250, 0.4);
    --interval-selected-fill: rgba(248, 113, 113, 0.14);
    --interval-selected-border: rgba(248, 113, 113, 0.7);
    --mean-spectrum-color: rgba(200, 200, 200, 1.0);
    --all-spectra-color: rgba(160, 160, 160, 0.25);
    --peak-color: rgba(251, 191, 36, 0.9);
    --grid-color: rgba(255, 255, 255, 0.08);
    --axis-text: #94A3B8;
}

*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
    background: var(--bg-primary); color: var(--text-primary);
    overflow: hidden; height: 100vh; display: flex; flex-direction: column;
    transition: background-color 0.3s ease, color 0.3s ease;
}

/* ---- Panel Toolbar ---- */
.panel-toolbar {
    display: flex; flex-direction: column; gap: 4px; flex-shrink: 0;
    padding-bottom: 4px; border-bottom: 1px solid var(--border-color);
}
.panel-toolbar-row {
    display: flex; align-items: center; gap: 6px;
}

/* ---- Dropdown Buttons ---- */
.dropdown { position: relative; display: inline-block; }
.dropdown-btn {
    background: linear-gradient(135deg, var(--accent-gradient-start), var(--accent-gradient-end));
    border: none; border-radius: 12px; padding: 8px 18px;
    color: white; font-size: 16px; font-weight: 600; cursor: pointer;
    display: flex; align-items: center; gap: 5px;
    box-shadow: 0 2px 8px rgba(100,181,246,0.25);
    transition: all 0.2s ease;
}
.dropdown-btn:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(100,181,246,0.35); }
.dropdown-btn .arrow { font-size: 10px; opacity: 0.8; }
.dropdown-btn--secondary {
    background: var(--button-bg); color: var(--button-text);
    border: 1px solid var(--button-border); box-shadow: none;
}
.dropdown-btn--secondary:hover { border-color: var(--accent-primary); transform: translateY(-1px); }
.dropdown-btn--toggle {
    background: var(--button-bg); color: var(--text-secondary);
    border: 1px solid var(--button-border); box-shadow: none;
    font-size: 12px; padding: 6px 10px;
}
.dropdown-btn--toggle:hover { border-color: var(--accent-primary); }
.dropdown-btn--toggle.active {
    background: var(--accent-primary); color: #fff;
    border-color: var(--accent-primary);
}
.dropdown-menu {
    display: none; position: absolute; top: 100%; left: 0; margin-top: 4px;
    background: var(--bg-secondary); border: 1px solid var(--border-color);
    border-radius: 12px; padding: 5px 0; min-width: 200px; z-index: 1000;
    box-shadow: 0 8px 24px var(--shadow-color);
}
.dropdown-menu.show { display: block; }
.dropdown-item {
    padding: 10px 18px; font-size: 16px; color: var(--text-primary);
    cursor: pointer; transition: background 0.15s ease;
}
.dropdown-item:hover { background: var(--bg-tertiary); }
.dropdown-sep { height: 1px; background: var(--border-color); margin: 5px 0; }

/* ---- Burger Menu ---- */
.burger-menu {
    display: none; position: absolute; top: 100%; right: 0; margin-top: 4px;
    background: var(--bg-secondary); border: 1px solid var(--border-color);
    border-radius: 12px; padding: 5px 0; min-width: 260px; z-index: 1000;
    box-shadow: 0 8px 24px var(--shadow-color);
}
.burger-menu.show { display: block; }
.burger-toggle {
    padding: 10px 18px; font-size: 16px; color: var(--text-primary);
    cursor: pointer; display: flex; align-items: center; justify-content: space-between;
    transition: background 0.15s ease;
}
.burger-toggle:hover { background: var(--bg-tertiary); }
.burger-toggle .check { color: var(--accent-primary); font-weight: 700; width: 22px; text-align: center; }


/* ---- Main Layout ---- */
.main-content { flex: 1; display: grid; grid-template-columns: 420px 1fr; gap: 0; overflow: hidden; }

/* ---- Left Panel ---- */
.controls-panel {
    background: var(--bg-secondary); border-right: 1px solid var(--border-color);
    overflow-y: auto; padding: 14px; display: flex; flex-direction: column; gap: 12px;
}
.controls-panel::-webkit-scrollbar { width: 8px; }
.controls-panel::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 4px; }

.section {
    background: var(--bg-tertiary); border-radius: 14px; padding: 14px;
    border: 1px solid var(--border-color); box-shadow: 0 1px 4px var(--shadow-color);
}
.section-title {
    font-size: 13px; font-weight: 600; color: var(--text-secondary);
    text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 10px;
}

/* ---- Tabs ---- */
.tab-bar {
    display: flex; gap: 0; border-bottom: 2px solid var(--border-color); margin-bottom: 12px;
}
.tab-btn {
    flex: 1; padding: 10px 16px; background: none; border: none;
    font-size: 16px; font-weight: 600; color: var(--text-tertiary);
    cursor: pointer; border-bottom: 2px solid transparent; margin-bottom: -2px;
    transition: all 0.2s ease;
}
.tab-btn:hover { color: var(--text-secondary); }
.tab-btn.active { color: var(--accent-primary); border-bottom-color: var(--accent-primary); }
.tab-content { display: none; }
.tab-content.active { display: block; }

/* ---- Buttons ---- */
.btn-primary {
    background: linear-gradient(135deg, var(--accent-gradient-start) 0%, var(--accent-gradient-end) 100%);
    border: none; border-radius: 12px; padding: 12px 18px; color: white;
    font-size: 16px; font-weight: 600; cursor: pointer;
    box-shadow: 0 3px 10px var(--shadow-accent);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    display: flex; align-items: center; justify-content: center; gap: 8px;
}
.btn-primary:hover { box-shadow: 0 5px 16px var(--shadow-accent); transform: translateY(-1px); }
.btn-primary:active { transform: translateY(0); }

.btn-secondary {
    background: var(--button-bg); border: 1px solid var(--button-border);
    border-radius: 12px; padding: 10px 18px; color: var(--button-text);
    font-size: 16px; font-weight: 500; cursor: pointer; transition: all 0.2s ease;
    display: flex; align-items: center; justify-content: center; gap: 6px;
}
.btn-secondary:hover { background: var(--accent-secondary); border-color: var(--accent-primary); color: var(--text-primary); transform: translateY(-1px); }

.btn-danger {
    background: transparent; border: 1px solid var(--error-color);
    border-radius: 10px; padding: 9px 18px; color: var(--error-color);
    font-size: 16px; font-weight: 500; cursor: pointer; transition: all 0.2s ease;
}
.btn-danger:hover { background: var(--error-color); color: white; }

.btn-row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
.btn-row-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; }
.btn-sm { padding: 8px 14px; font-size: 14px; border-radius: 10px; }

/* ---- Parameter Box ---- */
.param-box {
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 10px;
    padding: 12px;
    margin-bottom: 10px;
}
.param-box:last-child { margin-bottom: 0; }
.param-box .slider-group { margin-bottom: 0; }

/* ---- Slider with gear + nudge ---- */
.slider-group { margin-bottom: 10px; }
.slider-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; }
.slider-label { font-size: 14px; font-weight: 500; color: var(--text-secondary); }
.slider-controls { display: flex; align-items: center; gap: 5px; }
.slider-value {
    font-size: 14px; font-weight: 600; color: var(--accent-primary);
    font-family: 'SF Mono','Consolas',monospace;
    background: var(--bg-secondary); border: 1px solid var(--border-color);
    border-radius: 6px; padding: 3px 8px; width: 85px; text-align: right;
}
.slider-value:focus { outline: none; border-color: var(--accent-primary); }
.btn-nudge {
    width: 24px; height: 18px; background: var(--button-bg); border: 1px solid var(--border-color);
    border-radius: 4px; font-size: 10px; line-height: 1; cursor: pointer;
    color: var(--text-secondary); display: flex; align-items: center; justify-content: center;
    padding: 0; transition: all 0.15s ease;
}
.btn-nudge:hover { background: var(--accent-secondary); border-color: var(--accent-primary); }
.nudge-pair { display: flex; flex-direction: column; gap: 3px; }
.btn-gear {
    width: 28px; height: 28px; background: var(--button-bg); border: 1px solid var(--border-color);
    border-radius: 6px; font-size: 14px; cursor: pointer; color: var(--text-secondary);
    display: flex; align-items: center; justify-content: center; padding: 0;
    transition: all 0.15s ease;
}
.btn-gear:hover { background: var(--accent-secondary); border-color: var(--accent-primary); }

input[type="range"] {
    -webkit-appearance: none; width: 100%; height: 8px;
    background: var(--slider-track, #CBD5E1); border-radius: 4px; outline: none;
}
body.dark-mode input[type="range"] {
    background: #475569;
}
input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none; width: 22px; height: 22px;
    background: var(--accent-primary); border-radius: 50%; cursor: pointer;
    box-shadow: 0 2px 6px rgba(66, 165, 245, 0.4); transition: all 0.2s ease;
}
input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.15); }
input[type="range"]::-moz-range-thumb {
    width: 22px; height: 22px; background: var(--accent-primary);
    border-radius: 50%; cursor: pointer; border: none;
}
.slider-ticks {
    display: flex; justify-content: space-between; margin-top: 3px;
    font-size: 12px; color: var(--text-tertiary);
}

/* ---- Interval Table ---- */
.intervals-table-wrap {
    max-height: 220px; overflow-y: auto; border-radius: 10px;
    border: 1px solid var(--border-color); margin-top: 8px;
}
.intervals-table { width: 100%; border-collapse: collapse; font-size: 14px; }
.intervals-table th {
    background: var(--bg-secondary); color: var(--text-secondary);
    font-weight: 600; font-size: 12px; text-transform: uppercase; letter-spacing: 0.4px;
    padding: 8px 8px; text-align: center; position: sticky; top: 0; z-index: 1;
    border-bottom: 1px solid var(--border-color); cursor: pointer; user-select: none;
    transition: color 0.15s ease;
}
.intervals-table th:hover { color: var(--accent-primary); }
.intervals-table th .sort-arrow { font-size: 10px; margin-left: 2px; opacity: 0.4; }
.intervals-table th.sort-active .sort-arrow { opacity: 1; color: var(--accent-primary); }
.intervals-table th:last-child { cursor: default; }
.intervals-table td {
    padding: 6px 7px; border-bottom: 1px solid var(--border-color);
    color: var(--text-primary); text-align: center; font-family: 'SF Mono','Consolas',monospace;
}
.intervals-table tr:last-child td { border-bottom: none; }
.intervals-table tr:hover { background: rgba(66, 165, 245, 0.05); }
.intervals-table tr.selected { background: rgba(66, 165, 245, 0.12); }
.intervals-table td.editable { cursor: text; position: relative; }
.intervals-table td.editable:hover { background: rgba(66, 165, 245, 0.08); }
.intervals-table input.cell-edit {
    width: 100%; background: var(--bg-secondary); border: 1px solid var(--accent-primary);
    border-radius: 4px; padding: 3px 5px; font-size: 14px; color: var(--text-primary);
    text-align: center; font-family: 'SF Mono','Consolas',monospace;
}

/* Modal table inputs */
.modal-cell-input {
    width: 80px; background: var(--bg-tertiary); border: 1px solid var(--border-color);
    border-radius: 6px; padding: 6px 8px; font-size: 14px; color: var(--text-primary);
    text-align: center; font-family: 'SF Mono','Consolas',monospace;
    transition: border-color 0.2s ease;
}
.modal-cell-input:focus {
    outline: none;
    border-color: var(--accent-primary);
    background: var(--bg-secondary);
}
.modal-cell-input:hover {
    border-color: var(--accent-secondary);
}
.btn-remove-interval {
    background: transparent; border: none; color: var(--error-color);
    cursor: pointer; font-size: 16px; padding: 2px 6px; border-radius: 4px;
}
.btn-remove-interval:hover { background: var(--error-color); color: white; }

/* ---- Right Panel ---- */
.charts-panel { display: flex; flex-direction: column; gap: 0; padding: 8px; overflow: hidden; }
.chart-container {
    flex: 1; background: var(--bg-secondary); border-radius: 12px; padding: 8px 10px;
    border: 1px solid var(--border-color); box-shadow: 0 1px 4px var(--shadow-color);
    display: flex; flex-direction: column; min-height: 0; margin-bottom: 6px;
}
.chart-container:last-child { margin-bottom: 0; }
.chart-header { display: flex; justify-content: center; align-items: center; margin-bottom: 4px; flex-shrink: 0; position: relative; }
.chart-header .chart-title { position: absolute; left: 0; }
.chart-header .chart-header-badges { justify-content: center; }
.chart-title { font-size: 16px; font-weight: 600; color: var(--text-primary); }
.chart-wrapper { flex: 1; position: relative; min-height: 0; }
.chart-wrapper canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
.chart-empty {
    display: flex; align-items: center; justify-content: center;
    height: 100%; color: var(--text-tertiary); font-size: 16px; font-style: italic;
}
.chart-legend { display: flex; gap: 14px; font-size: 12px; color: var(--text-secondary); flex-shrink: 0; margin-top: 3px; }
.legend-item { display: flex; align-items: center; gap: 5px; }
.legend-swatch { width: 18px; height: 4px; border-radius: 2px; }

/* ---- Status Bar ---- */
.status-bar {
    background: var(--bg-secondary); padding: 4px 20px;
    border-top: 1px solid var(--border-color);
    display: flex; justify-content: space-between; align-items: center; flex-shrink: 0;
}
.status-left { display: flex; align-items: center; gap: 8px; font-size: 13px; color: var(--text-secondary); }
.status-indicator {
    width: 8px; height: 8px; border-radius: 50%;
    background: var(--status-indicator); animation: pulse 2s infinite;
}
.status-indicator.error { background: var(--error-color); animation: none; }
.status-indicator.processing { background: var(--warning-color); animation: pulse 1s infinite; }
@keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }

/* ---- Modal Overlay ---- */
.modal-overlay {
    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.4); display: flex; align-items: center; justify-content: center;
    z-index: 100;
}
.modal {
    background: var(--bg-secondary); border-radius: 18px; padding: 24px;
    border: 1px solid var(--border-color); box-shadow: 0 8px 32px rgba(0,0,0,0.2);
    min-width: 380px; max-width: 540px;
}
.modal-title { font-size: 18px; font-weight: 600; margin-bottom: 16px; }
.modal-btns { display: flex; gap: 10px; justify-content: flex-end; margin-top: 18px; }

/* ---- Success Toast/Popup ---- */
.toast-container {
    position: fixed; top: 20px; right: 20px; z-index: 200;
    display: flex; flex-direction: column; gap: 12px;
}
.toast {
    background: var(--bg-secondary); border-radius: 14px; padding: 16px 20px;
    border: 1px solid var(--border-color); box-shadow: 0 8px 32px rgba(0,0,0,0.25);
    display: flex; align-items: center; gap: 14px; min-width: 300px; max-width: 420px;
    animation: toastSlideIn 0.3s ease;
}
.toast-success { border-left: 4px solid #4caf50; }
.toast-info { border-left: 4px solid var(--accent-primary); }
.toast-warning { border-left: 4px solid #ff9800; }
.toast-icon {
    width: 40px; height: 40px; border-radius: 50%; display: flex;
    align-items: center; justify-content: center; font-size: 22px; flex-shrink: 0;
}
.toast-success .toast-icon { background: rgba(76,175,80,0.15); }
.toast-info .toast-icon { background: rgba(66,165,245,0.15); }
.toast-warning .toast-icon { background: rgba(255,152,0,0.15); }
.toast-content { flex: 1; }
.toast-title { font-weight: 600; font-size: 15px; margin-bottom: 2px; }
.toast-message { font-size: 13px; color: var(--text-secondary); }
.toast-close {
    background: none; border: none; color: var(--text-tertiary); cursor: pointer;
    font-size: 18px; padding: 4px; line-height: 1;
}
.toast-close:hover { color: var(--text-primary); }
@keyframes toastSlideIn {
    from { transform: translateX(100%); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
}
@keyframes toastSlideOut {
    from { transform: translateX(0); opacity: 1; }
    to { transform: translateX(100%); opacity: 0; }
}

/* ---- Progress Spinner ---- */
.spinner {
    width: 40px; height: 40px;
    border: 4px solid var(--border-color);
    border-top-color: var(--accent-primary);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
}
@keyframes spin {
    to { transform: rotate(360deg); }
}

/* ---- Progress Bar ---- */
.progress-container { text-align: center; }
.progress-bar-bg {
    width: 100%; height: 8px; background: var(--bg-tertiary);
    border-radius: 4px; overflow: hidden;
}
.progress-bar-fill {
    height: 100%; background: linear-gradient(90deg, var(--accent-primary), #66bb6a);
    border-radius: 4px; transition: width 0.2s ease;
}
.progress-text {
    margin-top: 8px; font-size: 13px; color: var(--text-secondary);
    font-family: 'SF Mono','Consolas',monospace;
}

/* ---- Form ---- */
.form-group { margin-bottom: 8px; }
.form-label { font-size: 14px; font-weight: 500; color: var(--text-secondary); margin-bottom: 4px; display: block; }
.form-input {
    width: 100%; background: var(--bg-secondary); border: 1px solid var(--border-color);
    border-radius: 8px; padding: 8px 12px; font-size: 16px; color: var(--text-primary);
    transition: all 0.2s ease; font-family: 'SF Mono','Consolas',monospace;
}
.form-input:focus { outline: none; border-color: var(--accent-primary); box-shadow: 0 0 0 2px rgba(66,165,245,0.15); }

/* ---- Checkbox Toggle ---- */
.divider { height: 1px; background: var(--border-color); margin: 3px 0; }

/* ---- Interval placeholder ---- */
.interval-placeholder {
    padding: 20px; text-align: center; color: var(--text-tertiary);
    font-size: 16px; font-style: italic;
}

/* Drawing cursor */
/* Drawing mode cursor is now handled by JavaScript to allow resize cursor near edges */

/* ---- Circular Chart Badges ---- */
.chart-header-badges {
    display: flex;
    gap: 10px;
    align-items: center;
}
.badge-group {
    display: flex;
    gap: 8px;
    align-items: center;
}
.badge-separator {
    width: 1px;
    height: 24px;
    background: var(--border-color);
    margin: 0 14px;
}
.chart-badge.disabled {
    opacity: 0.35;
    cursor: default;
    pointer-events: none;
}
.chart-badges {
    position: absolute;
    top: 12px;
    right: 16px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    z-index: 10;
}
.chart-badge {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: var(--bg-secondary);
    border: 2px solid var(--border-color);
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 2px 8px var(--shadow-color);
    font-size: 18px;
}
.chart-badge:hover {
    background: var(--accent-secondary);
    border-color: var(--accent-primary);
    transform: scale(1.1);
}
.chart-badge.active {
    background: var(--accent-primary);
    border-color: var(--accent-primary);
    color: white;
}
.chart-badge svg {
    width: 20px;
    height: 20px;
    fill: currentColor;
}
.chart-badge-small {
    width: 34px;
    height: 34px;
    font-size: 14px;
}

/* ---- Showcase/Tutorial Mode ---- */
.showcase-overlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.05);
    z-index: 1000;
    pointer-events: all;
}
.showcase-highlight-clone {
    position: fixed;
    z-index: 1001;
    pointer-events: auto;
    cursor: pointer;
    border-radius: 8px;
    box-shadow:
        0 0 0 4px #FFD700,
        0 0 20px 8px rgba(255,215,0,0.5),
        0 0 40px 16px rgba(255,215,0,0.3);
    animation: showcaseGoldPulse 1.5s ease-in-out infinite;
    overflow: hidden;
}
@keyframes showcaseGoldPulse {
    0%, 100% {
        box-shadow:
            0 0 0 4px #FFD700,
            0 0 20px 8px rgba(255,215,0,0.5),
            0 0 40px 16px rgba(255,215,0,0.3);
    }
    50% {
        box-shadow:
            0 0 0 6px #FFC107,
            0 0 30px 12px rgba(255,193,7,0.6),
            0 0 50px 20px rgba(255,193,7,0.4);
    }
}
.showcase-click-hint {
    position: absolute;
    bottom: -35px;
    left: 50%;
    transform: translateX(-50%);
    background: #FFD700;
    color: #000;
    padding: 4px 12px;
    border-radius: 12px;
    font-size: 12px;
    font-weight: 600;
    white-space: nowrap;
    animation: bounceHint 1s ease-in-out infinite;
}
@keyframes bounceHint {
    0%, 100% { transform: translateX(-50%) translateY(0); }
    50% { transform: translateX(-50%) translateY(-4px); }
}
.showcase-tooltip {
    position: fixed;
    background: var(--bg-secondary);
    border: 2px solid var(--accent-primary);
    border-radius: 16px;
    padding: 20px 24px;
    max-width: 400px;
    min-width: 300px;
    z-index: 1003;
    box-shadow: 0 8px 32px rgba(0,0,0,0.4);
    animation: tooltipFadeIn 0.3s ease;
}
.showcase-tooltip.showcase-final {
    max-width: 500px;
    min-width: 400px;
}
.showcase-tooltip.showcase-final .showcase-text {
    text-align: left;
    font-size: 0.95em;
}
@keyframes tooltipFadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}
.showcase-tooltip::before {
    display: none;
}
.showcase-step {
    font-size: 12px;
    color: var(--accent-primary);
    font-weight: 600;
    margin-bottom: 8px;
    text-transform: uppercase;
    letter-spacing: 1px;
}
.showcase-title {
    font-size: 18px;
    font-weight: 600;
    margin-bottom: 10px;
    color: var(--text-primary);
}
.showcase-text {
    font-size: 14px;
    line-height: 1.6;
    color: var(--text-secondary);
    margin-bottom: 16px;
}
.showcase-text code {
    background: var(--bg-tertiary);
    padding: 2px 6px;
    border-radius: 4px;
    font-family: 'SF Mono', 'Consolas', monospace;
    font-size: 13px;
}
.showcase-btns {
    display: flex;
    gap: 10px;
    justify-content: flex-end;
}
.showcase-btn {
    padding: 8px 18px;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    border: none;
    transition: all 0.2s ease;
}
.showcase-btn-secondary {
    background: var(--bg-tertiary);
    color: var(--text-secondary);
}
.showcase-btn-secondary:hover { background: var(--border-color); }
.showcase-close {
    position: absolute;
    top: 12px;
    right: 12px;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    border: none;
    background: var(--bg-tertiary);
    color: var(--text-secondary);
    font-size: 16px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
}
.showcase-close:hover {
    background: var(--error-color);
    color: white;
}
.showcase-btn-primary {
    background: var(--accent-primary);
    color: white;
}
.showcase-btn-primary:hover { background: #1e88e5; }
.showcase-btn-action {
    background: #4caf50;
    color: white;
}
.showcase-btn-action:hover { background: #43a047; }
.showcase-progress {
    display: flex;
    gap: 6px;
    margin-bottom: 16px;
}
.showcase-dot {
    width: 8px; height: 8px;
    border-radius: 50%;
    background: var(--border-color);
    transition: all 0.2s ease;
}
.showcase-dot.active { background: var(--accent-primary); width: 24px; border-radius: 4px; }
.showcase-dot.done { background: #4caf50; }
.showcase-icon {
    font-size: 40px;
    margin-bottom: 12px;
}
.showcase-welcome {
    text-align: center;
    padding: 20px;
}
</style>
</head>
<body>

<!-- Toast container for notifications -->
<div class="toast-container" id="toast-container"></div>

<!-- MAIN -->
<div class="main-content">

    <!-- LEFT PANEL -->
    <div class="controls-panel">

        <!-- Toolbar -->
        <div class="panel-toolbar">
            <div class="panel-toolbar-row">
                <div class="dropdown">
                    <button id="btn-load" class="dropdown-btn" onclick="sendAction('loadData')">Load</button>
                    <div class="dropdown-menu" id="menu-load">
                        <div class="dropdown-item" onclick="sendAction('loadData')">From Workspace</div>
                        <div class="dropdown-item" onclick="loadIntervalTable()">Load Intervals</div>
                    </div>
                </div>
                <div class="dropdown">
                    <button id="btn-apply" class="dropdown-btn" onclick="applyCorrection()">Apply</button>
                    <div class="dropdown-menu" id="menu-apply">
                        <div class="dropdown-item" onclick="applyCorrection()">Apply to All</div>
                    </div>
                </div>
                <button class="dropdown-btn dropdown-btn--secondary" onclick="importParams()">Import</button>
                <button class="dropdown-btn dropdown-btn--secondary" onclick="exportData()">Export</button>
            </div>
        </div>

        <!-- Tabbed Parameters -->
        <div class="section">
            <div class="tab-bar">
                <button class="tab-btn active" onclick="switchTab('global')">Global</button>
                <button class="tab-btn" onclick="switchTab('interval')">Interval</button>
            </div>

            <!-- Global Tab -->
            <div class="tab-content active" id="tab-global">
                <div style="display:flex;justify-content:flex-end;margin-bottom:6px;">
                    <button class="btn-secondary btn-sm" onclick="resetGlobalDefaults()" style="padding:4px 10px;font-size:12px;" title="Reset global parameters to defaults">Reset defaults</button>
                </div>
                <!-- Lambda (log) -->
                <div class="param-box">
                    <div class="slider-group">
                        <div class="slider-header">
                            <span class="slider-label"><i>&lambda;</i> &mdash; smoothness</span>
                            <div class="slider-controls">
                                <input type="text" class="slider-value" id="val-lambda" value="100000">
                                <div class="nudge-pair">
                                    <button class="btn-nudge" onclick="nudgeLog('lambda',1)">&#9650;</button>
                                    <button class="btn-nudge" onclick="nudgeLog('lambda',-1)">&#9660;</button>
                                </div>
                                <button class="btn-gear" onclick="openSliderSettings('lambda')" title="Configure range">&#9881;&#65039;</button>
                            </div>
                        </div>
                        <input type="range" id="slider-lambda" min="-3" max="8" step="0.01" value="5" oninput="onLogSlider('lambda', this.value)">
                        <div class="slider-ticks" id="ticks-lambda"></div>
                    </div>
                </div>

                <!-- p (linear) -->
                <div class="param-box">
                    <div class="slider-group">
                        <div class="slider-header">
                            <span class="slider-label"><i>p</i> &mdash; asymmetry (outside)</span>
                            <div class="slider-controls">
                                <input type="text" class="slider-value" id="val-p" value="0.001">
                                <div class="nudge-pair">
                                    <button class="btn-nudge" onclick="nudgeLinear('p',1)">&#9650;</button>
                                    <button class="btn-nudge" onclick="nudgeLinear('p',-1)">&#9660;</button>
                                </div>
                                <button class="btn-gear" onclick="openPSettings('p')" title="Configure range">&#9881;&#65039;</button>
                            </div>
                        </div>
                        <input type="range" id="slider-p" min="0" max="1" step="0.001" value="0.001" oninput="onLinearSlider('p', this.value)">
                        <div class="slider-ticks" id="ticks-p"></div>
                    </div>
                </div>

                <!-- mu (log) -->
                <div class="param-box">
                    <div class="slider-group">
                        <div class="slider-header">
                            <span class="slider-label"><i>&mu;</i> &mdash; baseline tension</span>
                            <div class="slider-controls">
                                <input type="text" class="slider-value" id="val-mu" value="0">
                                <div class="nudge-pair">
                                    <button class="btn-nudge" onclick="nudgeLog('mu',1)">&#9650;</button>
                                    <button class="btn-nudge" onclick="nudgeLog('mu',-1)">&#9660;</button>
                                </div>
                                <button class="btn-gear" onclick="openSliderSettings('mu')" title="Configure range">&#9881;&#65039;</button>
                            </div>
                        </div>
                        <input type="range" id="slider-mu" min="-3" max="6" step="0.01" value="-3" oninput="onLogSlider('mu', this.value)">
                        <div class="slider-ticks" id="ticks-mu"></div>
                    </div>
                </div>
            </div>

            <!-- Interval Tab -->
            <div class="tab-content" id="tab-interval">
                <div id="interval-no-selection" class="interval-placeholder">
                    No interval selected &mdash; draw or click one
                </div>
                <div id="selected-interval-panel" style="display:none;">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;">
                        <div style="font-size: 14px; color: var(--accent-primary); font-weight: 600;" id="selected-info">Selected: (none)</div>
                        <button class="btn-secondary btn-sm" onclick="resetIntervalToGlobal()" style="padding:4px 10px;font-size:12px;" title="Reset to global defaults">Reset to global</button>
                    </div>

                    <div class="param-box">
                        <div class="slider-group">
                            <div class="slider-header">
                                <span class="slider-label"><i>&lambda;</i><sub>in</sub> (inside selected)</span>
                                <div class="slider-controls">
                                    <input type="text" class="slider-value" id="val-lambda-in" value="100000">
                                    <div class="nudge-pair">
                                        <button class="btn-nudge" onclick="nudgeLog('lambdaIn',1)">&#9650;</button>
                                        <button class="btn-nudge" onclick="nudgeLog('lambdaIn',-1)">&#9660;</button>
                                    </div>
                                    <button class="btn-gear" onclick="openSliderSettings('lambdaIn')">&#9881;&#65039;</button>
                                </div>
                            </div>
                            <input type="range" id="slider-lambda-in" min="-3" max="8" step="0.01" value="3" oninput="onInsideLogSlider('lambdaIn', this.value)">
                        </div>
                    </div>

                    <div class="param-box">
                        <div class="slider-group">
                            <div class="slider-header">
                                <span class="slider-label"><i>p</i><sub>in</sub> (inside selected)</span>
                                <div class="slider-controls">
                                    <input type="text" class="slider-value" id="val-p-in" value="0.001">
                                    <div class="nudge-pair">
                                        <button class="btn-nudge" onclick="nudgeLinear('pIn',1)">&#9650;</button>
                                        <button class="btn-nudge" onclick="nudgeLinear('pIn',-1)">&#9660;</button>
                                    </div>
                                    <button class="btn-gear" onclick="openPSettings('pIn')">&#9881;&#65039;</button>
                                </div>
                            </div>
                            <input type="range" id="slider-p-in" min="0" max="0.05" step="0.0001" value="0.001" oninput="onInsideLinearSlider('pIn', this.value)">
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Intervals Section -->
        <div class="section">
            <div class="section-title">Intervals</div>
            <div class="btn-row-3" style="margin-bottom: 8px;">
                <button class="btn-primary btn-sm" id="btn-draw-interval" onclick="startDrawInterval()" disabled>Draw</button>
                <button class="btn-danger btn-sm" id="btn-delete-selected" onclick="deleteSelectedIntervals()" disabled>Delete sel.</button>
                <button class="btn-danger btn-sm" id="btn-clear-intervals" onclick="clearIntervals()">Clear all</button>
            </div>

            <!-- Interval table (read-only, click to select) -->
            <div class="intervals-table-wrap" id="intervals-table-wrap" style="display:none;">
                <table class="intervals-table">
                    <thead><tr>
                        <th onclick="sortIntervalTable('index')"># <span class="sort-arrow">&#9650;</span></th>
                        <th onclick="sortIntervalTable('start')">Start <span class="sort-arrow">&#9650;</span></th>
                        <th onclick="sortIntervalTable('end')">End <span class="sort-arrow">&#9650;</span></th>
                        <th onclick="sortIntervalTable('width')">W <span class="sort-arrow">&#9650;</span></th>
                        <th onclick="sortIntervalTable('lambda')"><i>&lambda;</i> <span class="sort-arrow">&#9650;</span></th>
                        <th onclick="sortIntervalTable('p')"><i>p</i> <span class="sort-arrow">&#9650;</span></th>
                        <th onclick="sortIntervalTable('area')">Area <span class="sort-arrow">&#9650;</span></th>
                        <th onclick="sortIntervalTable('max')">Max <span class="sort-arrow">&#9650;</span></th>
                        <th onclick="sortIntervalTable('min')">Min <span class="sort-arrow">&#9650;</span></th>
                        <th></th>
                    </tr></thead>
                    <tbody id="intervals-tbody"></tbody>
                </table>
            </div>
        </div>

        <!-- Peak Navigation (shown when peaks detected) -->
        <div class="section" id="peak-section" style="display:none;">
            <div class="section-title">Peaks</div>
            <div style="display: flex; align-items: center; gap: 6px;">
                <button class="btn-secondary btn-sm" id="btn-prev-peak" onclick="stepPeak(-1)" disabled>&#9664; Prev</button>
                <span id="peak-label" style="font-size: 14px; color: var(--text-secondary); flex: 1; text-align: center;"></span>
                <button class="btn-secondary btn-sm" id="btn-next-peak" onclick="stepPeak(+1)" disabled>Next &#9654;</button>
            </div>
        </div>
    </div>

    <!-- RIGHT PANEL -->
    <div class="charts-panel">
        <div class="chart-container">
            <div class="chart-header">
                <span class="chart-title">Preview Baseline</span>
                <div class="chart-header-badges" id="chart-badges">
                    <!-- Group 1: View & Detection -->
                    <div class="badge-group">
                        <div class="chart-badge chart-badge-small" onclick="resetZoom('preview')" title="Reset view">
                            <svg viewBox="0 0 24 24"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg>
                        </div>
                        <div class="chart-badge chart-badge-small" id="badge-detect-peaks" onclick="togglePeakDetection()" title="Auto-detect peaks">
                            <svg viewBox="0 0 24 24"><path d="M3 17h2v5H3v-5zm6-8h2v13H9V9zm6 4h2v9h-2v-9zm6-10h2v19h-2V3z"/></svg>
                        </div>
                    </div>
                    <div class="badge-separator"></div>
                    <!-- Group 2: Signal mode -->
                    <div class="badge-group">
                        <div class="chart-badge chart-badge-small" id="badge-signal-mode" onclick="toggleBurgerOption('signalMode')" title="Signal-by-signal mode">
                            <svg viewBox="0 0 24 24"><path d="M3 5h18v2H3V5zm0 6h18v2H3v-2zm0 6h18v2H3v-2z" opacity=".35"/><path d="M3 5h18v2H3V5z"/></svg>
                        </div>
                        <div class="chart-badge chart-badge-small disabled" id="badge-per-signal" onclick="toggleBurgerOption('perSignal')" title="Per-signal parameters">
                            <svg viewBox="0 0 24 24"><path d="M3 17v2h6v-2H3zM3 5v2h10V5H3zm10 16v-2h8v-2h-8v-2h-2v6h2zM7 9v2H3v2h4v2h2V9H7zm14 4v-2H11v2h10zm-6-4h2V7h4V5h-4V3h-2v6z"/></svg>
                        </div>
                    </div>
                    <div class="badge-separator"></div>
                    <!-- Group 3: Signal navigation -->
                    <div class="badge-group">
                        <div class="chart-badge chart-badge-small disabled" id="badge-prev-signal" onclick="stepSignal(-1)" title="Previous signal">
                            <svg viewBox="0 0 24 24"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/></svg>
                        </div>
                        <div class="chart-badge chart-badge-small disabled" id="badge-signal-index" title="Current signal (click to edit)" style="min-width:40px;font-size:11px;cursor:text;user-select:none;">
                            <span id="signal-index-label" onclick="editSignalIndex()">1/1</span>
                            <input id="signal-index-input" type="text" style="display:none;width:36px;border:none;background:transparent;color:inherit;font-size:11px;text-align:center;outline:none;padding:0;" onkeydown="handleSignalIndexKey(event)" onblur="commitSignalIndex()">
                        </div>
                        <div class="chart-badge chart-badge-small disabled" id="badge-next-signal" onclick="stepSignal(1)" title="Next signal">
                            <svg viewBox="0 0 24 24"><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/></svg>
                        </div>
                    </div>
                    <!-- + Menu (right-aligned) -->
                    <div class="dropdown" style="position:absolute;right:0">
                        <div class="chart-badge chart-badge-small" id="burger-btn" onclick="toggleBurgerMenu()" title="More options">
                            <svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
                        </div>
                        <div class="burger-menu" id="burger-menu">
                            <div style="padding:6px 18px 4px;font-size:11px;font-weight:700;color:var(--text-tertiary);text-transform:uppercase;letter-spacing:1px;">Display</div>
                            <div class="burger-toggle" onclick="toggleBurgerOption('signalMode')">
                                <span>Signal-by-signal</span><span class="check" id="chk-signalMode"></span>
                            </div>
                            <div class="burger-toggle" onclick="toggleBurgerOption('perSignal')">
                                <span>Per-signal params</span><span class="check" id="chk-perSignal"></span>
                            </div>
                            <div class="burger-toggle" onclick="toggleBurgerOption('showAll')">
                                <span>Show all spectra</span><span class="check" id="chk-showAll"></span>
                            </div>
                            <div class="dropdown-sep"></div>
                            <div style="padding:6px 18px 4px;font-size:11px;font-weight:700;color:var(--text-tertiary);text-transform:uppercase;letter-spacing:1px;">Peaks</div>
                            <div class="burger-toggle" onclick="toggleBurgerOption('peakNavMode')">
                                <span>Apply peak detection to all samples</span><span class="check" id="chk-peakNavMode"></span>
                            </div>
                            <div class="dropdown-item" onclick="openPeakSettings(); closeBurger();">Peak detection settings...</div>
                            <div class="dropdown-sep"></div>
                            <div style="padding:6px 18px 4px;font-size:11px;font-weight:700;color:var(--text-tertiary);text-transform:uppercase;letter-spacing:1px;">Settings</div>
                            <div class="burger-toggle" onclick="toggleBurgerOption('fastPreview')">
                                <span>Fast preview</span><span class="check" id="chk-fastPreview"></span>
                            </div>
                            <div class="dropdown-item" onclick="openSolverSettings(); closeBurger();">Solver settings...</div>
                            <div class="dropdown-item" onclick="resetAllViews(); closeBurger();">Reset all views</div>
                            <div class="burger-toggle" onclick="toggleDarkMode()">
                                <span>Dark mode</span><span class="check" id="chk-darkMode"></span>
                            </div>
                            <div class="dropdown-sep"></div>
                            <div class="dropdown-item" onclick="startShowcase(); closeBurger();" id="btn-tutorial">Tutorial</div>
                            <div class="dropdown-item" onclick="showHelp(); closeBurger();">Help</div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="chart-wrapper" id="preview-wrapper">
                <canvas id="preview-canvas"></canvas>
                <div class="chart-empty" id="preview-empty">Load data to preview baseline</div>
            </div>
            <div class="chart-legend" id="preview-legend" style="display:none;">
                <div class="legend-item"><div class="legend-swatch" id="swatch-spectrum"></div><span id="legend-spectrum-label">Mean</span></div>
                <div class="legend-item"><div class="legend-swatch" id="swatch-baseline"></div>Baseline</div>
                <div class="legend-item"><div class="legend-swatch" id="swatch-interval"></div>Intervals</div>
            </div>
        </div>
        <div class="chart-container">
            <div class="chart-header">
                <span class="chart-title">Corrected Spectrum</span>
                <div class="chart-header-badges">
                    <div class="chart-badge chart-badge-small" onclick="resetZoom('corrected')" title="Reset view">
                        <svg viewBox="0 0 24 24"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg>
                    </div>
                </div>
            </div>
            <div class="chart-wrapper" id="corrected-wrapper">
                <canvas id="corrected-canvas"></canvas>
                <div class="chart-empty" id="corrected-empty">Apply correction to view</div>
            </div>
            <div class="chart-legend" id="corrected-legend" style="display:none;">
                <div class="legend-item"><div class="legend-swatch" id="swatch-corrected"></div><span id="legend-corrected-label">Corrected</span></div>
            </div>
        </div>
    </div>
</div>

<!-- STATUS BAR -->
<div class="status-bar">
    <div class="status-left">
        <div class="status-indicator" id="status-indicator"></div>
        <span id="status-message">Ready</span>
    </div>
</div>

<script>
/* ====================================================================
   STATE
   ==================================================================== */
var htmlComponent = null;
var lastTimestamp = -1;

/* Data */
var wavelength = [];
var meanSpectrum = [];
var currentSpectrum = [];
var allSpectra = [];
var baselineData = [];
var correctedPreview = [];
var allCorrectedData = [];

/* Signal navigation */
var signalMode = false;
var currentSignal = 1;
var nSamples = 0;
var nChannels = 0;

/* Per-signal mode */
var perSignalMode = false;
var perSignalIntervals = {};
var perSignalGlobalParams = {};

/* Intervals */
var intervals = [];
var selectedIdx = -1;

/* Peaks */
var peaksEnabled = false;
var peaks = [];
var currentPeak = -1;
var peakGlowState = [];  // Glow intensity 0-1 for each peak
var peakAnimationFrame = null;
var peakAnimationStart = 0;

/* Peak detection settings */
var peakMinProminence = 0.05;  // Minimum prominence as fraction of range (0-1)
var peakMinDistance = 0;       // Minimum distance between peaks (0 = auto)

/* Solver */
var solverMaxIter = 50;
var solverTol = 1e-6;

/* Show all spectra */
var showAllSpectra = false;
/* Slider configs - lambda min of -3 is special: represents 0 */
var sliderCfg = {
    lambda:   { min: -3, max: 8, allowZero: true },
    mu:       { min: -3, max: 6, allowZero: true },
    lambdaIn: { min: -3, max: 8, allowZero: true }
};
var pCfg = {
    p:   { min: 0, max: 1, step: 0.01 },
    pIn: { min: 0, max: 0.05, step: 0.001 }
};

/* View state */
var previewView = null;
var correctedView = null;
var panState = null;

/* Drawing state */
var drawingMode = false;
var drawStart = null;
var drawCurrent = null;

/* Interval resize state */
var resizeState = null;  // { intervalIdx, edge: 'left'|'right', startX }
var EDGE_THRESHOLD = 8;  // pixels from edge to trigger resize cursor

/* Nudge factor */
var NUDGE_FACTOR = 1.05;
var AUTO_PREVIEW_DELAY = 3;
var autoPreviewTimer = null;

/* ====================================================================
   THEME
   ==================================================================== */
function toggleDarkMode() {
    document.body.classList.toggle('dark-mode');
    localStorage.setItem('lasls_darkMode', document.body.classList.contains('dark-mode'));
    var chk = document.getElementById('chk-darkMode');
    if (chk) chk.textContent = document.body.classList.contains('dark-mode') ? '\u2713' : '';
    updateLegendSwatches();
    renderAll();
}
if (localStorage.getItem('lasls_darkMode') === 'true') document.body.classList.add('dark-mode');
document.addEventListener('keydown', function(e) { if (e.ctrlKey && e.key === 'd') { e.preventDefault(); toggleDarkMode(); } });

/* ====================================================================
   DROPDOWN / BURGER MENU LOGIC
   ==================================================================== */
function closeAllMenus() {
    var menus = document.querySelectorAll('.dropdown-menu, .burger-menu');
    for (var i = 0; i < menus.length; i++) menus[i].classList.remove('show');
}

function closeAllDropdowns() {
    closeAllMenus();
}

function toggleDropdown(menuId) {
    var menu = document.getElementById(menuId);
    if (!menu) return;
    var wasOpen = menu.classList.contains('show');
    closeAllMenus();
    if (!wasOpen) menu.classList.add('show');
}

function closeBurger() {
    document.getElementById('burger-menu').classList.remove('show');
}

function toggleBurgerMenu() {
    var bm = document.getElementById('burger-menu');
    var wasOpen = bm.classList.contains('show');
    closeAllMenus();
    if (!wasOpen) bm.classList.add('show');
}

/* Toggle dropdown on arrow click */
document.addEventListener('click', function(e) {
    var arrow = e.target.closest('.arrow');
    if (arrow) {
        e.stopPropagation();
        var btn = arrow.closest('.dropdown-btn');
        var menu = btn.parentElement.querySelector('.dropdown-menu');
        var wasOpen = menu.classList.contains('show');
        closeAllMenus();
        if (!wasOpen) menu.classList.add('show');
        return;
    }

    /* Close menus if clicking outside */
    if (!e.target.closest('#burger-btn') && !e.target.closest('.dropdown-menu') && !e.target.closest('.burger-menu')) {
        closeAllMenus();
    }
});

function toggleBurgerOption(option) {
    switch (option) {
        case 'signalMode':
            signalMode = !signalMode;
            onSignalModeChanged();
            break;
        case 'perSignal':
            perSignalMode = !perSignalMode;
            // Per-signal params requires signal-by-signal mode
            if (perSignalMode && !signalMode) {
                signalMode = true;
                showAllSpectra = false;
                updateSignalNav();
                // Use allSpectra if available, otherwise request from MATLAB
                if (allSpectra && allSpectra.length > 0) {
                    currentSignal = 1;
                    currentSpectrum = allSpectra[0].slice();
                    renderAll();
                    scheduleAutoPreview();
                } else {
                    requestSpectrum(currentSignal);
                }
            }
            onPerSignalChanged();
            break;
        case 'showAll':
            // Show all spectra is incompatible with signal-by-signal mode
            if (signalMode) {
                setStatus('info', 'Disable signal-by-signal mode first to show all spectra');
                return;
            }
            if (!showAllSpectra && nSamples * nChannels > 25000000) {
                showToast('warning', 'Performance Warning',
                    'Displaying all ' + nSamples + ' spectra (' + (nSamples * nChannels / 1e6).toFixed(1) + 'M data points) may be slow.', 6000);
            }
            showAllSpectra = !showAllSpectra;
            onShowAllChanged();
            break;
        case 'peakNavMode':
            togglePeakDetection();
            break;
        case 'fastPreview':
            fastPreviewMode = !fastPreviewMode;
            onFastPreviewChanged();
            break;
    }
    updateBurgerChecks();
}

function updateBurgerChecks() {
    document.getElementById('chk-signalMode').textContent = signalMode ? '\u2713' : '';
    document.getElementById('chk-perSignal').textContent = perSignalMode ? '\u2713' : '';
    document.getElementById('chk-showAll').textContent = showAllSpectra ? '\u2713' : '';
    document.getElementById('chk-peakNavMode').textContent = peakNavMode ? '\u2713' : '';
    document.getElementById('chk-fastPreview').textContent = fastPreviewMode ? '\u2713' : '';
    document.getElementById('chk-darkMode').textContent = document.body.classList.contains('dark-mode') ? '\u2713' : '';
    // Update header badges state
    var smBadge = document.getElementById('badge-signal-mode');
    if (smBadge) {
        if (signalMode) smBadge.classList.add('active');
        else smBadge.classList.remove('active');
    }
    var psBadge = document.getElementById('badge-per-signal');
    if (psBadge) {
        if (signalMode) psBadge.classList.remove('disabled');
        else psBadge.classList.add('disabled');
        if (perSignalMode) psBadge.classList.add('active');
        else psBadge.classList.remove('active');
    }
    var prevBadge = document.getElementById('badge-prev-signal');
    var nextBadge = document.getElementById('badge-next-signal');
    var indexBadge = document.getElementById('badge-signal-index');
    if (prevBadge) {
        if (signalMode && nSamples > 1) prevBadge.classList.remove('disabled');
        else prevBadge.classList.add('disabled');
    }
    if (nextBadge) {
        if (signalMode && nSamples > 1) nextBadge.classList.remove('disabled');
        else nextBadge.classList.add('disabled');
    }
    if (indexBadge) {
        if (signalMode && nSamples > 1) indexBadge.classList.remove('disabled');
        else indexBadge.classList.add('disabled');
    }
    updateSignalIndexLabel();
    updateLegendSwatches();
}

/* ====================================================================
   TAB SWITCHING
   ==================================================================== */
function switchTab(tabName) {
    var tabs = document.querySelectorAll('.tab-btn');
    var contents = document.querySelectorAll('.tab-content');
    for (var i = 0; i < tabs.length; i++) {
        tabs[i].classList.remove('active');
        contents[i].classList.remove('active');
    }
    if (tabName === 'global') {
        tabs[0].classList.add('active');
        contents[0].classList.add('active');
    } else {
        tabs[1].classList.add('active');
        contents[1].classList.add('active');
    }
}

/* Fast preview mode (enabled by default) */
var fastPreviewMode = true;

/* ====================================================================
   AUTO-PREVIEW
   ==================================================================== */
function scheduleAutoPreview() {
    if (currentSpectrum.length === 0) return;
    clearTimeout(autoPreviewTimer);
    if (fastPreviewMode) {
        // Immediate JS-based computation
        autoPreviewTimer = setTimeout(function() { computeJSBaseline(); }, 10);
    } else {
        // Send to MATLAB for computation
        autoPreviewTimer = setTimeout(function() { previewBaseline(); }, AUTO_PREVIEW_DELAY);
    }
}

function onFastPreviewChanged() {
    updateBurgerChecks();

    if (fastPreviewMode) {
        setStatus('info', 'Fast preview enabled');
        computeJSBaseline();
    } else {
        setStatus('info', 'Fast preview disabled - using MATLAB');
        previewBaseline();
    }
}

/* ====================================================================
   FAST PREVIEW - Asymmetric Least Squares (Whittaker smoother)
   Implements: z = (W + lambda*D'D)^{-1} * W * y
   where D is second-difference matrix, W is asymmetric weight matrix
   ==================================================================== */
function computeJSBaseline() {
    if (currentSpectrum.length < 5) return;

    var gp = getGlobalParams();
    var y = currentSpectrum;
    var n = y.length;

    // Build per-point parameter vectors
    // pVec: global p outside intervals, interval p inside intervals
    // lambdaVec: smoothness per difference row (n-2 rows for second-order diff)
    var pVec = new Float64Array(n);
    var lambdaVec = new Float64Array(n - 2);

    // Initialize with global values
    for (var i = 0; i < n; i++) pVec[i] = gp.p;
    for (var i = 0; i < n - 2; i++) lambdaVec[i] = gp.lambda;

    // Override with interval-specific values
    for (var k = 0; k < intervals.length; k++) {
        var intv = intervals[k];
        var iStart = intv.startIdx - 1;  // Convert to 0-based
        var iEnd = intv.endIdx - 1;

        if (iStart < 0 || iEnd >= n || iStart > iEnd) continue;

        // Override p for data points within this interval
        for (var i = iStart; i <= iEnd; i++) {
            pVec[i] = intv.p;
        }

        // Override lambda for difference rows that overlap this interval
        // Second-order difference at row r involves indices r, r+1, r+2
        var rowStart = Math.max(0, iStart - 1);
        var rowEnd = Math.min(n - 3, iEnd - 1);
        for (var r = rowStart; r <= rowEnd; r++) {
            lambdaVec[r] = intv.lambda;
        }
    }

    // Compute baseline using true LAsLS (unified system with varying parameters)
    var baseline = laslsCompute(y, pVec, lambdaVec, gp.mu, solverMaxIter);

    // Update display
    baselineData = baseline;
    correctedPreview = new Array(n);
    for (var i = 0; i < n; i++) {
        correctedPreview[i] = y[i] - baseline[i];
    }

    computeIntervalMetrics();
    updateIntervalTable();
    renderAll();
}

/**
 * LAsLS - Local Asymmetric Least Squares baseline correction
 * Matches the MATLAB implementation exactly.
 * Solves: (W + D'*diag(lambdaVec)*D + mu*L'*L) * z = W * y
 * where D is second-order diff [1,-2,1], L is first-order diff [-1,1]
 */
function laslsCompute(y, pVec, lambdaVec, mu, maxIter) {
    var n = y.length;
    if (n < 5) return y.slice();

    var tol = solverTol;

    // Initialize weights uniformly
    var w = new Float64Array(n);
    for (var i = 0; i < n; i++) w[i] = 1.0;

    var z = new Float64Array(n);
    var prevZ = new Float64Array(n);

    for (var iter = 0; iter < maxIter; iter++) {
        // Copy previous baseline for convergence check
        for (var i = 0; i < n; i++) prevZ[i] = z[i];

        // Build and solve the system
        z = solveLaslsSystem(y, w, lambdaVec, mu, n);

        // Check convergence (relative change in baseline)
        var normZ = 0, normDiff = 0;
        for (var i = 0; i < n; i++) {
            normZ += z[i] * z[i];
            var d = z[i] - prevZ[i];
            normDiff += d * d;
        }
        var relChange = Math.sqrt(normDiff) / (Math.sqrt(normZ) + 1e-10);
        if (relChange < tol && iter > 0) break;

        // Update weights based on pVec (asymmetric weighting everywhere)
        for (var i = 0; i < n; i++) {
            w[i] = (y[i] > z[i]) ? pVec[i] : (1 - pVec[i]);
        }
    }

    // Convert to regular array
    var result = new Array(n);
    for (var i = 0; i < n; i++) result[i] = z[i];
    return result;
}

/**
 * Solve the LAsLS system: (W + D'*diag(lambdaVec)*D + mu*L'*L) * z = W * y
 * D is second-order diff [1,-2,1] of size (n-2) x n
 * L is first-order diff [-1,1] of size (n-1) x n
 * lambdaVec has n-2 elements (one per row of D)
 */
function solveLaslsSystem(y, w, lambdaVec, mu, n) {
    // Build the pentadiagonal matrix A = W + D'*diag(lambdaVec)*D + mu*L'*L
    // D'*diag(lambdaVec)*D contributes to diagonals 0, 1, 2
    // L'*L contributes to diagonals 0, 1

    var d0 = new Float64Array(n);  // Main diagonal
    var d1 = new Float64Array(n);  // First sub-diagonal (i, i+1)
    var d2 = new Float64Array(n);  // Second sub-diagonal (i, i+2)

    // Build D'*diag(lambdaVec)*D contributions
    // For element (i,j): sum over r where D[r,i] and D[r,j] are both non-zero
    // D[r,k] non-zero for k in {r, r+1, r+2} with values [1, -2, 1]

    // Main diagonal d0[i]: contributions from r = i-2, i-1, i (where valid)
    for (var i = 0; i < n; i++) {
        var val = w[i];  // Start with weight

        // D'*diag(lambdaVec)*D contributions
        // r = i-2: D[i-2,i] = 1, contribution = lambdaVec[i-2] * 1 * 1
        if (i >= 2 && i - 2 < n - 2) val += lambdaVec[i - 2] * 1;
        // r = i-1: D[i-1,i] = -2, contribution = lambdaVec[i-1] * 4
        if (i >= 1 && i - 1 < n - 2) val += lambdaVec[i - 1] * 4;
        // r = i: D[i,i] = 1, contribution = lambdaVec[i] * 1
        if (i < n - 2) val += lambdaVec[i] * 1;

        // L'*L contribution: main diagonal is 2 for interior, 1 for boundaries
        if (i === 0 || i === n - 1) val += mu * 1;
        else val += mu * 2;

        // Ensure diagonal is never zero (prevents solver failure)
        d0[i] = Math.max(1e-10, val);
    }

    // First sub-diagonal d1[i] = A[i, i+1]
    for (var i = 0; i < n - 1; i++) {
        var val = 0;

        // D'*diag(lambdaVec)*D contributions for (i, i+1)
        // r = i-1: D[i-1,i] = -2, D[i-1,i+1] = 1, contribution = lambdaVec[i-1] * (-2) * 1
        if (i >= 1 && i - 1 < n - 2) val += lambdaVec[i - 1] * (-2);
        // r = i: D[i,i] = 1, D[i,i+1] = -2, contribution = lambdaVec[i] * 1 * (-2)
        if (i < n - 2) val += lambdaVec[i] * (-2);

        // L'*L contribution: off-diagonal is -1
        val += mu * (-1);

        d1[i] = val;
    }

    // Second sub-diagonal d2[i] = A[i, i+2]
    for (var i = 0; i < n - 2; i++) {
        // D'*diag(lambdaVec)*D contribution for (i, i+2)
        // r = i: D[i,i] = 1, D[i,i+2] = 1, contribution = lambdaVec[i] * 1 * 1
        d2[i] = lambdaVec[i] * 1;
    }

    // Right-hand side: W * y
    var b = new Float64Array(n);
    for (var i = 0; i < n; i++) b[i] = w[i] * y[i];

    // Solve using banded Cholesky
    return solveBandedCholesky(d0, d1, d2, b, n);
}

/**
 * Banded Cholesky solver for symmetric pentadiagonal system
 * Uses LDLT decomposition: A = L * D * L'
 */
function solveBandedCholesky(d0, d1, d2, b, n) {
    // LDLT decomposition
    var L1 = new Float64Array(n);  // First sub-diagonal of L
    var L2 = new Float64Array(n);  // Second sub-diagonal of L
    var D = new Float64Array(n);   // Diagonal of D

    // Forward pass: compute L and D
    D[0] = d0[0];

    if (n > 1) {
        L1[0] = d1[0] / D[0];
        D[1] = d0[1] - L1[0] * L1[0] * D[0];
    }

    for (var i = 2; i < n; i++) {
        L2[i - 2] = d2[i - 2] / D[i - 2];
        L1[i - 1] = (d1[i - 1] - L2[i - 2] * L1[i - 2] * D[i - 2]) / D[i - 1];
        D[i] = d0[i] - L2[i - 2] * L2[i - 2] * D[i - 2] - L1[i - 1] * L1[i - 1] * D[i - 1];

        // Numerical stability check
        if (D[i] < 1e-12) D[i] = 1e-12;
    }

    // Forward substitution: L * y = b
    var y = new Float64Array(n);
    y[0] = b[0];
    if (n > 1) y[1] = b[1] - L1[0] * y[0];
    for (var i = 2; i < n; i++) {
        y[i] = b[i] - L1[i - 1] * y[i - 1] - L2[i - 2] * y[i - 2];
    }

    // Diagonal solve: D * z = y
    var z = new Float64Array(n);
    for (var i = 0; i < n; i++) {
        z[i] = y[i] / D[i];
    }

    // Back substitution: L' * x = z
    var x = new Float64Array(n);
    x[n - 1] = z[n - 1];
    if (n > 1) x[n - 2] = z[n - 2] - L1[n - 2] * x[n - 1];
    for (var i = n - 3; i >= 0; i--) {
        x[i] = z[i] - L1[i] * x[i + 1] - L2[i] * x[i + 2];
    }

    return x;
}

/* ====================================================================
   SLIDER HELPERS
   ==================================================================== */
function onLogSlider(param, logVal) {
    var lv = parseFloat(logVal);
    var cfg = sliderCfg[param];
    // If at minimum and allowZero, treat as 0
    var actualVal = (cfg && cfg.allowZero && lv <= cfg.min) ? 0 : Math.pow(10, lv);
    document.getElementById('val-' + param).value = fmtNum(actualVal);
    scheduleAutoPreview();
}
function onLinearSlider(param, val) {
    document.getElementById('val-' + param).value = parseFloat(val).toFixed(4);
    scheduleAutoPreview();
}
function onInsideLogSlider(param, logVal) {
    var lv = parseFloat(logVal);
    var cfg = sliderCfg[param];
    // If at minimum and allowZero, treat as 0
    var v = (cfg && cfg.allowZero && lv <= cfg.min) ? 0 : Math.pow(10, lv);
    document.getElementById('val-' + param.replace('In','-in')).value = fmtNum(v);
    if (selectedIdx >= 0 && selectedIdx < intervals.length) {
        intervals[selectedIdx].lambda = v;
        updateIntervalTable();
    }
    renderAll();
    scheduleAutoPreview();
}
function onInsideLinearSlider(param, val) {
    var v = parseFloat(val);
    document.getElementById('val-' + param.replace('In','-in')).value = v.toFixed(4);
    if (selectedIdx >= 0 && selectedIdx < intervals.length) {
        intervals[selectedIdx].p = v;
        updateIntervalTable();
    }
    renderAll();
    scheduleAutoPreview();
}

function fmtNum(v) {
    if (v === 0) return '0';
    if (v >= 1e6) return v.toExponential(1);
    if (v >= 1000) return Math.round(v).toString();
    if (v >= 1) return v.toFixed(1);
    if (v >= 0.01) return v.toFixed(3);
    return v.toExponential(1);
}

function nudgeLog(param, dir) {
    var ids = { lambda: 'val-lambda', mu: 'val-mu', lambdaIn: 'val-lambda-in' };
    var slIds = { lambda: 'slider-lambda', mu: 'slider-mu', lambdaIn: 'slider-lambda-in' };
    var cfg = sliderCfg[param];
    var el = document.getElementById(ids[param]);
    var v = parseFloat(el.value) || 1;

    // Handle nudging from 0 or to 0
    if (cfg && cfg.allowZero) {
        if (v === 0 && dir > 0) {
            v = Math.pow(10, cfg.min); // Start from minimum non-zero value
        } else if (v > 0) {
            v = dir > 0 ? v * NUDGE_FACTOR : v / NUDGE_FACTOR;
            if (v < Math.pow(10, cfg.min)) v = 0; // Go to 0 when below minimum
        }
    } else {
        v = dir > 0 ? v * NUDGE_FACTOR : v / NUDGE_FACTOR;
        v = Math.max(1e-10, v);
    }

    el.value = fmtNum(v);
    document.getElementById(slIds[param]).value = (v === 0) ? cfg.min : Math.log10(v);
    if (param === 'lambdaIn' && selectedIdx >= 0 && selectedIdx < intervals.length) {
        intervals[selectedIdx].lambda = v;
        updateIntervalTable();
        renderAll();
    }
    scheduleAutoPreview();
}

function nudgeLinear(param, dir) {
    var ids = { p: 'val-p', pIn: 'val-p-in' };
    var slIds = { p: 'slider-p', pIn: 'slider-p-in' };
    var cfg = pCfg[param];
    var el = document.getElementById(ids[param]);
    var v = parseFloat(el.value) || 0;
    v += dir * cfg.step;
    v = Math.max(cfg.min, Math.min(cfg.max, v));
    el.value = v.toFixed(4);
    document.getElementById(slIds[param]).value = v;
    if (param === 'pIn' && selectedIdx >= 0 && selectedIdx < intervals.length) {
        intervals[selectedIdx].p = v;
        updateIntervalTable();
        renderAll();
    }
    scheduleAutoPreview();
}

/* Sync typed value -> slider */
function syncSliderFromInput(inputId, sliderId, isLog, paramName) {
    document.getElementById(inputId).addEventListener('change', function() {
        var v = parseFloat(this.value);
        if (isNaN(v)) return;
        var cfg = paramName ? sliderCfg[paramName] : null;
        // Allow 0 for parameters that support it
        if (cfg && cfg.allowZero) {
            if (v < 0) return;
            if (v === 0) {
                document.getElementById(sliderId).value = cfg.min;
                scheduleAutoPreview();
                return;
            }
        } else {
            if (v <= 0) return;
        }
        document.getElementById(sliderId).value = isLog ? Math.log10(v) : v;
        scheduleAutoPreview();
    });
}

document.addEventListener('DOMContentLoaded', function() {
    syncSliderFromInput('val-lambda', 'slider-lambda', true, 'lambda');
    syncSliderFromInput('val-p', 'slider-p', false, null);
    syncSliderFromInput('val-mu', 'slider-mu', true, 'mu');
    syncSliderFromInput('val-lambda-in', 'slider-lambda-in', true, 'lambdaIn');
    syncSliderFromInput('val-p-in', 'slider-p-in', false, null);
    initAllTicks();

    // Also sync inside params text input -> interval value
    document.getElementById('val-lambda-in').addEventListener('change', function() {
        var v = parseFloat(this.value);
        if (isNaN(v) || v < 0) return;
        if (selectedIdx >= 0 && selectedIdx < intervals.length) {
            intervals[selectedIdx].lambda = v;
            updateIntervalTable();
            renderAll();
        }
    });
    document.getElementById('val-p-in').addEventListener('change', function() {
        var v = parseFloat(this.value);
        if (isNaN(v) || v < 0) return;
        if (selectedIdx >= 0 && selectedIdx < intervals.length) {
            intervals[selectedIdx].p = v;
            // Auto-expand slider range
            if (v > pCfg.pIn.max) {
                pCfg.pIn.max = Math.min(1, v * 2);
                var sl = document.getElementById('slider-p-in');
                sl.max = pCfg.pIn.max;
            }
            document.getElementById('slider-p-in').value = v;
            updateIntervalTable();
            renderAll();
        }
    });

    updateBurgerChecks();
});

/* ====================================================================
   READ PARAMETERS
   ==================================================================== */
function getGlobalParams() {
    var lambda = parseFloat(document.getElementById('val-lambda').value);
    var p = parseFloat(document.getElementById('val-p').value);
    var mu = parseFloat(document.getElementById('val-mu').value);
    return {
        lambda:    isNaN(lambda) ? 100000 : lambda,
        p:         isNaN(p) ? 0.001 : p,
        mu:        isNaN(mu) ? 0 : mu,
        maxIter:   solverMaxIter,
        tolerance: solverTol
    };
}

/* ====================================================================
   ACTIONS -> MATLAB
   ==================================================================== */
function sendAction(action, extra) {
    if (!htmlComponent) return;
    var payload = extra || {};
    payload.action = action;
    payload.timestamp = Date.now();
    htmlComponent.Data = payload;
}

function previewBaseline() {
    var p = getGlobalParams();
    p.signalMode = signalMode;
    p.signalIndex = currentSignal;

    // Serialize intervals as flat arrays for reliable MATLAB parsing
    if (intervals.length > 0) {
        p.intStarts = intervals.map(function(v) { return v.startIdx; });
        p.intEnds = intervals.map(function(v) { return v.endIdx; });
        p.intLambdas = intervals.map(function(v) { return v.lambda; });
        p.intPs = intervals.map(function(v) { return v.p; });
    }
    sendAction('previewBaseline', p);
}

function applyCorrection() {
    if (!htmlComponent) {
        setStatus('error', 'Error: htmlComponent not initialized');
        return;
    }
    showProgressOverlay('Applying baseline correction...', true);
    if (perSignalMode) saveCurrentSignalParams();
    var p = getGlobalParams();
    p.intervals = intervals;
    p.perSignalMode = perSignalMode;

    if (perSignalMode) {
        var psIdx = [], psS = [], psE = [], psL = [], psPv = [];
        var glLam = [], glP = [], glMu = [];
        for (var s = 1; s <= nSamples; s++) {
            var ints = perSignalIntervals[s] || [];
            var gp = perSignalGlobalParams[s] || { lambda: p.lambda, p: p.p, mu: p.mu };
            glLam.push(gp.lambda); glP.push(gp.p); glMu.push(gp.mu);
            for (var j = 0; j < ints.length; j++) {
                psIdx.push(s); psS.push(ints[j].startIdx); psE.push(ints[j].endIdx);
                psL.push(ints[j].lambda); psPv.push(ints[j].p);
            }
        }
        p.psIntervalSignalIdx = psIdx; p.psIntervalStart = psS; p.psIntervalEnd = psE;
        p.psIntervalLambda = psL; p.psIntervalP = psPv;
        p.psGlobalLambda = glLam; p.psGlobalP = glP; p.psGlobalMu = glMu;
    }
    sendAction('apply', p);
}

function exportData() {
    if (!htmlComponent) {
        setStatus('error', 'Error: htmlComponent not initialized');
        return;
    }
    // Request export dialog from MATLAB (checks for existing vars)
    sendAction('prepareExport');
}

function collectExportParams() {
    // Collect all parameters for reproducibility
    var p = getGlobalParams();
    var params = {
        lambda: p.lambda,
        p: p.p,
        mu: p.mu,
        maxIter: p.maxIter,
        tolerance: p.tolerance,
        perSignalMode: perSignalMode,
        intervals: []
    };

    // Collect intervals (including table metrics)
    for (var i = 0; i < intervals.length; i++) {
        var intv = intervals[i];
        var entry = {
            startIdx: intv.startIdx,
            endIdx: intv.endIdx,
            width: intv.endIdx - intv.startIdx,
            lambda: intv.lambda,
            p: intv.p
        };
        if (intv._area !== undefined) entry.area = intv._area;
        if (intv._max !== undefined) entry.max = intv._max;
        if (intv._min !== undefined) entry.min = intv._min;
        params.intervals.push(entry);
    }

    // Collect per-signal data if in per-signal mode
    if (perSignalMode) {
        params.perSignalIntervals = {};
        params.perSignalGlobalParams = {};
        for (var s = 1; s <= nSamples; s++) {
            if (perSignalIntervals[s]) {
                params.perSignalIntervals[s] = perSignalIntervals[s];
            }
            if (perSignalGlobalParams[s]) {
                params.perSignalGlobalParams[s] = perSignalGlobalParams[s];
            }
        }
    }

    return params;
}

function importParams() {
    if (!htmlComponent) {
        setStatus('error', 'Error: htmlComponent not initialized');
        return;
    }
    // Request list of parameter structs from workspace
    sendAction('prepareImport');
}

function showImportModal(payload) {
    var vars = payload.variables || [];

    var ov = document.createElement('div');
    ov.className = 'modal-overlay';

    var md = document.createElement('div');
    md.className = 'modal';
    md.style.minWidth = '420px';
    md.style.maxHeight = '70vh';
    md.style.display = 'flex';
    md.style.flexDirection = 'column';

    var html = '<div class="modal-title">Import Parameters</div>';

    if (vars.length === 0) {
        html += '<div style="padding:40px 20px;text-align:center;color:var(--text-secondary);">';
        html += '<div style="font-size:48px;margin-bottom:16px;">&#128237;</div>';
        html += '<div style="font-size:16px;font-weight:500;margin-bottom:8px;">No parameter structs found</div>';
        html += '<div style="font-size:14px;">Export parameters first using the Export button, then import them here.</div>';
        html += '</div>';
        html += '<div class="modal-btns">';
        html += '<button class="btn-secondary btn-sm" id="import-modal-cancel">Close</button>';
        html += '</div>';
    } else {
        html += '<div style="margin-bottom:12px;color:var(--text-secondary);font-size:14px;">Select a parameter struct to import:</div>';
        html += '<div style="flex:1;overflow-y:auto;border:1px solid var(--border-color);border-radius:8px;margin-bottom:16px;">';
        html += '<table class="intervals-table" style="width:100%"><thead><tr>';
        html += '<th style="width:40px;"></th><th>Variable</th><th>Intervals</th><th>Mode</th>';
        html += '</tr></thead><tbody>';

        for (var i = 0; i < vars.length; i++) {
            var v = vars[i];
            var mode = v.perSignalMode ? 'Per-Signal' : 'Global';
            html += '<tr class="import-row" data-varname="' + v.name + '" style="cursor:pointer;">';
            html += '<td style="text-align:center;"><input type="radio" name="import-select" value="' + v.name + '"' + (i === 0 ? ' checked' : '') + '></td>';
            html += '<td style="font-weight:600;">' + v.name + '</td>';
            html += '<td>' + v.nIntervals + '</td>';
            html += '<td>' + mode + '</td>';
            html += '</tr>';
        }

        html += '</tbody></table></div>';
        html += '<div class="modal-btns">';
        html += '<button class="btn-secondary btn-sm" id="import-modal-cancel">Cancel</button>';
        html += '<button class="btn-primary btn-sm" id="import-modal-confirm">Import</button>';
        html += '</div>';
    }

    md.innerHTML = html;
    ov.appendChild(md);
    document.body.appendChild(ov);

    // Row click selects the radio button
    var rows = md.querySelectorAll('.import-row');
    for (var j = 0; j < rows.length; j++) {
        rows[j].onclick = function() {
            var radio = this.querySelector('input[type="radio"]');
            radio.checked = true;
        };
    }

    document.getElementById('import-modal-cancel').onclick = function() {
        ov.remove();
        setStatus('idle', '');
    };

    var confirmBtn = document.getElementById('import-modal-confirm');
    if (confirmBtn) {
        confirmBtn.onclick = function() {
            var selected = md.querySelector('input[name="import-select"]:checked');
            if (selected) {
                ov.remove();
                sendAction('doImport', { varName: selected.value });
            }
        };
    }

    ov.onclick = function(e) { if (e.target === ov) { ov.remove(); setStatus('idle', ''); } };
}

function applyImportedParams(p) {
    // Apply global parameters, auto-expand slider ranges if needed, and move sliders
    if (p.lambda !== undefined) {
        var lv = parseFloat(p.lambda);
        document.getElementById('val-lambda').value = lv;
        var logLam = lv > 0 ? Math.log10(lv) : sliderCfg.lambda.min;
        if (logLam > sliderCfg.lambda.max) { sliderCfg.lambda.max = Math.ceil(logLam); document.getElementById('slider-lambda').max = sliderCfg.lambda.max; }
        if (lv > 0 && logLam < sliderCfg.lambda.min) { sliderCfg.lambda.min = Math.floor(logLam); document.getElementById('slider-lambda').min = sliderCfg.lambda.min; }
        document.getElementById('slider-lambda').value = logLam;
        updateLogTicks('lambda');
    }
    if (p.p !== undefined) {
        var pv = parseFloat(p.p);
        document.getElementById('val-p').value = pv;
        if (pv > pCfg.p.max) { pCfg.p.max = Math.min(1, pv * 1.2); document.getElementById('slider-p').max = pCfg.p.max; }
        if (pv < pCfg.p.min) { pCfg.p.min = Math.max(0, pv * 0.8); document.getElementById('slider-p').min = pCfg.p.min; }
        document.getElementById('slider-p').value = pv;
        updateLinearTicks('p');
    }
    if (p.mu !== undefined) {
        var mv = parseFloat(p.mu);
        document.getElementById('val-mu').value = mv;
        var logMu = mv > 0 ? Math.log10(mv) : sliderCfg.mu.min;
        if (logMu > sliderCfg.mu.max) { sliderCfg.mu.max = Math.ceil(logMu); document.getElementById('slider-mu').max = sliderCfg.mu.max; }
        if (mv > 0 && logMu < sliderCfg.mu.min) { sliderCfg.mu.min = Math.floor(logMu); document.getElementById('slider-mu').min = sliderCfg.mu.min; }
        document.getElementById('slider-mu').value = logMu;
        updateLogTicks('mu');
    }
    if (p.maxIter !== undefined) solverMaxIter = p.maxIter;
    if (p.tolerance !== undefined) solverTolerance = p.tolerance;

    // Apply intervals
    intervals = [];
    if (p.intervals) {
        var ints = p.intervals;
        // Handle both array and struct with numeric keys
        if (Array.isArray(ints)) {
            for (var i = 0; i < ints.length; i++) {
                intervals.push({
                    startIdx: ints[i].startIdx,
                    endIdx: ints[i].endIdx,
                    lambda: ints[i].lambda,
                    p: ints[i].p
                });
            }
        } else {
            var keys = Object.keys(ints);
            for (var k = 0; k < keys.length; k++) {
                var item = ints[keys[k]];
                intervals.push({
                    startIdx: item.startIdx,
                    endIdx: item.endIdx,
                    lambda: item.lambda,
                    p: item.p
                });
            }
        }
    }

    // Apply per-signal mode
    if (p.perSignalMode) {
        perSignalMode = true;
        if (p.perSignalIntervals) {
            perSignalIntervals = {};
            var psi = p.perSignalIntervals;
            var psiKeys = Object.keys(psi);
            for (var m = 0; m < psiKeys.length; m++) {
                var sig = parseInt(psiKeys[m]);
                var sigInts = psi[psiKeys[m]];
                perSignalIntervals[sig] = [];
                if (Array.isArray(sigInts)) {
                    for (var n = 0; n < sigInts.length; n++) {
                        perSignalIntervals[sig].push(sigInts[n]);
                    }
                } else {
                    var siKeys = Object.keys(sigInts);
                    for (var o = 0; o < siKeys.length; o++) {
                        perSignalIntervals[sig].push(sigInts[siKeys[o]]);
                    }
                }
            }
        }
        if (p.perSignalGlobalParams) {
            perSignalGlobalParams = {};
            var psg = p.perSignalGlobalParams;
            var psgKeys = Object.keys(psg);
            for (var q = 0; q < psgKeys.length; q++) {
                var sigNum = parseInt(psgKeys[q]);
                perSignalGlobalParams[sigNum] = psg[psgKeys[q]];
            }
        }
    } else {
        perSignalMode = false;
    }

    // Update UI
    updateIntervalTable();
    if (intervals.length > 0) {
        selectedIdx = 0;
        updateSelectedIntervalPanel();
    }
    renderAll();
    showToast('success', 'Parameters Imported', intervals.length + ' intervals and settings loaded.');
    setStatus('success', 'Imported ' + intervals.length + ' intervals');
}

/* ---- Toast Notifications ---- */
function showToast(type, title, message, duration) {
    duration = duration || 4000;
    var container = document.getElementById('toast-container');
    var toast = document.createElement('div');
    toast.className = 'toast toast-' + type;

    var icons = { success: '&#10003;', info: '&#8505;', warning: '&#9888;' };
    toast.innerHTML =
        '<div class="toast-icon">' + (icons[type] || '&#8226;') + '</div>' +
        '<div class="toast-content">' +
            '<div class="toast-title">' + title + '</div>' +
            '<div class="toast-message">' + message + '</div>' +
        '</div>' +
        '<button class="toast-close" onclick="this.parentElement.remove()">&#215;</button>';

    container.appendChild(toast);

    setTimeout(function() {
        toast.style.animation = 'toastSlideOut 0.3s ease forwards';
        setTimeout(function() { if (toast.parentElement) toast.remove(); }, 300);
    }, duration);
}

/* ---- Progress Overlay ---- */
var progressOverlay = null;
function showProgressOverlay(message, showProgressBar) {
    if (progressOverlay) return;
    progressOverlay = document.createElement('div');
    progressOverlay.className = 'modal-overlay';
    progressOverlay.style.backdropFilter = 'blur(4px)';

    var progressBarHtml = '';
    if (showProgressBar) {
        progressBarHtml =
            '<div class="progress-container" style="margin-top:16px;width:280px;">' +
                '<div class="progress-bar-bg">' +
                    '<div class="progress-bar-fill" id="progress-bar-fill" style="width:0%"></div>' +
                '</div>' +
                '<div class="progress-text" id="progress-text">0 / 0</div>' +
            '</div>';
    }

    progressOverlay.innerHTML =
        '<div style="background:var(--bg-secondary);border-radius:18px;padding:32px 48px;text-align:center;border:1px solid var(--border-color);box-shadow:0 8px 32px rgba(0,0,0,0.3);min-width:320px;">' +
            '<div class="spinner" style="margin:0 auto 16px;"></div>' +
            '<div style="font-size:16px;font-weight:500;" id="progress-message">' + message + '</div>' +
            progressBarHtml +
        '</div>';
    document.body.appendChild(progressOverlay);
}
function hideProgressOverlay() {
    if (progressOverlay) {
        progressOverlay.remove();
        progressOverlay = null;
    }
}

function updateProgress(current, total) {
    if (!progressOverlay) return;
    var pct = total > 0 ? Math.round((current / total) * 100) : 0;
    var fill = document.getElementById('progress-bar-fill');
    var text = document.getElementById('progress-text');
    var msg = document.getElementById('progress-message');
    if (fill) fill.style.width = pct + '%';
    if (text) text.textContent = current + ' / ' + total + ' spectra';
    if (msg) {
        if (current === 0) {
            msg.textContent = 'Starting correction of ' + total + ' spectra...';
        } else {
            msg.textContent = 'Correcting spectrum ' + current + ' of ' + total + '...';
        }
    }
}

/* ---- Export Modal ---- */
function showExportModal(info) {
    var hasData = info.hasCorrected;
    var hasBaseline = info.hasBaseline;
    var hasWeights = info.hasWeights;
    var existingVars = info.existingVars || [];

    if (!hasData) {
        showToast('warning', 'No Data', 'Apply correction first before exporting.');
        return;
    }

    var ov = document.createElement('div');
    ov.className = 'modal-overlay';

    var md = document.createElement('div');
    md.className = 'modal';
    md.style.minWidth = '420px';

    var html = '<div class="modal-title">Export to Workspace</div>';
    html += '<div style="margin-bottom:16px;color:var(--text-secondary);font-size:14px;">Choose variable names for export:</div>';

    // Corrected data (always available)
    var correctedExists = existingVars.indexOf('correctedData') >= 0;
    html += '<div class="form-group">';
    html += '<label class="form-label">Corrected Data' + (correctedExists ? ' <span style="color:#ff9800;">(exists)</span>' : '') + '</label>';
    html += '<input type="text" class="form-input" id="export-corrected-name" value="correctedData">';
    html += '</div>';

    // Baseline (optional)
    if (hasBaseline) {
        var baselineExists = existingVars.indexOf('baselineData') >= 0;
        html += '<div class="form-group">';
        html += '<label class="form-label">Baseline Data' + (baselineExists ? ' <span style="color:#ff9800;">(exists)</span>' : '') + '</label>';
        html += '<input type="text" class="form-input" id="export-baseline-name" value="baselineData">';
        html += '</div>';
    }

    // Weights (optional)
    if (hasWeights) {
        var weightsExists = existingVars.indexOf('weightsData') >= 0;
        html += '<div class="form-group">';
        html += '<label class="form-label">Weights Data' + (weightsExists ? ' <span style="color:#ff9800;">(exists)</span>' : '') + '</label>';
        html += '<input type="text" class="form-input" id="export-weights-name" value="weightsData">';
        html += '</div>';
    }

    // Parameters (for reproducibility)
    html += '<div class="divider" style="margin:16px 0;"></div>';
    var paramsExists = existingVars.indexOf('laslsParams') >= 0;
    html += '<div class="form-group">';
    html += '<label class="form-label">Parameters (for reproducibility)' + (paramsExists ? ' <span style="color:#ff9800;">(exists)</span>' : '') + '</label>';
    html += '<input type="text" class="form-input" id="export-params-name" value="laslsParams">';
    html += '<div style="font-size:12px;color:var(--text-tertiary);margin-top:4px;">Contains: lambda, p, mu, intervals, per-signal settings</div>';
    html += '</div>';

    if (existingVars.length > 0) {
        html += '<div style="margin-top:12px;padding:10px;background:rgba(255,152,0,0.1);border-radius:8px;font-size:13px;color:#ff9800;">';
        html += '<strong>&#9888; Variables marked "(exists)" will be overwritten. Change names to avoid.</strong>';
        html += '</div>';
    }

    html += '<div class="modal-btns">';
    html += '<button class="btn-secondary btn-sm" id="export-modal-cancel">Cancel</button>';
    html += '<button class="btn-primary btn-sm" id="export-modal-confirm">Export</button>';
    html += '</div>';

    md.innerHTML = html;
    ov.appendChild(md);
    document.body.appendChild(ov);

    document.getElementById('export-modal-cancel').onclick = function() {
        ov.remove();
        setStatus('idle', '');
    };

    document.getElementById('export-modal-confirm').onclick = function() {
        var names = {
            correctedName: document.getElementById('export-corrected-name').value.trim(),
            paramsName: document.getElementById('export-params-name').value.trim()
        };
        if (hasBaseline) names.baselineName = document.getElementById('export-baseline-name').value.trim();
        if (hasWeights) names.weightsName = document.getElementById('export-weights-name').value.trim();

        // Collect current parameters to export
        names.params = collectExportParams();

        ov.remove();
        sendAction('doExport', names);
    };

    ov.onclick = function(e) { if (e.target === ov) { ov.remove(); setStatus('idle', ''); } };
}

function exportIntervalTable() {
    if (perSignalMode) saveCurrentSignalParams();
    var d = {};
    if (perSignalMode) {
        var ss=[],se=[],sl=[],sp=[],si=[],slo=[],spo=[],smu=[];
        for (var s = 1; s <= nSamples; s++) {
            var ints = perSignalIntervals[s] || [];
            var gp = perSignalGlobalParams[s] || getGlobalParams();
            for (var j = 0; j < ints.length; j++) {
                si.push(s); ss.push(ints[j].startIdx); se.push(ints[j].endIdx);
                sl.push(ints[j].lambda); sp.push(ints[j].p);
                slo.push(gp.lambda); spo.push(gp.p); smu.push(gp.mu);
            }
        }
        d.tableSignalIdx = si; d.tableStarts = ss; d.tableEnds = se;
        d.tableLambdas = sl; d.tablePs = sp;
        d.tableLambdaOut = slo; d.tablePOut = spo; d.tableMu = smu;
    } else {
        d.tableStarts = intervals.map(function(v){return v.startIdx;});
        d.tableEnds = intervals.map(function(v){return v.endIdx;});
        d.tableLambdas = intervals.map(function(v){return v.lambda;});
        d.tablePs = intervals.map(function(v){return v.p;});
    }
    sendAction('exportIntervals', d);
}

function loadIntervalTable() { sendAction('loadIntervals'); }

/* ====================================================================
   SIGNAL NAVIGATION
   ==================================================================== */
function onSignalModeChanged() {
    updateSignalNav();
    if (signalMode) {
        showAllSpectra = false;
        updateBurgerChecks();
        requestSpectrum(currentSignal);
    } else {
        // Per-signal mode requires signal-by-signal, so disable it too
        if (perSignalMode) {
            perSignalMode = false;
            onPerSignalChanged();
        }
        currentSpectrum = meanSpectrum.slice();
        previewView = null;
        renderAll();
        scheduleAutoPreview();
    }
    updateBurgerChecks();
}

function updateSignalNav() {
    // Signal navigation is handled by chart header badges
}

function stepSignal(dir) {
    if (!signalMode) return;
    if (perSignalMode) saveCurrentSignalParams();
    currentSignal = Math.max(1, Math.min(nSamples, currentSignal + dir));
    if (perSignalMode) loadCurrentSignalParams();

    // If allSpectra is available, use it directly instead of requesting from MATLAB
    if (allSpectra && allSpectra.length >= currentSignal && allSpectra[currentSignal - 1]) {
        currentSpectrum = allSpectra[currentSignal - 1].slice();
        baselineData = [];
        correctedPreview = [];
        previewView = null;
        // Re-detect peaks and recreate intervals for this signal if peak detection is active
        if (peakNavMode) {
            detectPeaks();
            autoCreateIntervalsFromPeaks();
            if (peaks.length > 0) {
                currentPeak = 0;
                updatePeakLabel();
            }
        }
        // For fast preview, compute baseline immediately to avoid showing stale data
        if (fastPreviewMode) {
            computeJSBaseline();
        } else {
            renderAll();
            scheduleAutoPreview();
        }
    } else {
        requestSpectrum(currentSignal);
    }
    updateSignalIndexLabel();
}

function updateSignalIndexLabel() {
    var lbl = document.getElementById('signal-index-label');
    if (lbl) lbl.textContent = currentSignal + '/' + (nSamples || 1);
}

function editSignalIndex() {
    if (!signalMode || nSamples <= 1) return;
    var lbl = document.getElementById('signal-index-label');
    var inp = document.getElementById('signal-index-input');
    if (!lbl || !inp) return;
    lbl.style.display = 'none';
    inp.style.display = 'inline';
    inp.value = currentSignal;
    inp.focus();
    inp.select();
}

function handleSignalIndexKey(e) {
    if (e.key === 'Enter') { e.target.blur(); }
    else if (e.key === 'Escape') {
        var lbl = document.getElementById('signal-index-label');
        var inp = document.getElementById('signal-index-input');
        inp.style.display = 'none';
        lbl.style.display = 'inline';
    }
}

function commitSignalIndex() {
    var lbl = document.getElementById('signal-index-label');
    var inp = document.getElementById('signal-index-input');
    if (!lbl || !inp) return;
    inp.style.display = 'none';
    lbl.style.display = 'inline';
    var val = parseInt(inp.value);
    if (isNaN(val) || val < 1) val = 1;
    if (val > nSamples) val = nSamples;
    if (val !== currentSignal) {
        if (perSignalMode) saveCurrentSignalParams();
        currentSignal = val;
        if (perSignalMode) loadCurrentSignalParams();
        if (allSpectra && allSpectra.length >= currentSignal && allSpectra[currentSignal - 1]) {
            currentSpectrum = allSpectra[currentSignal - 1].slice();
            baselineData = [];
            correctedPreview = [];
            previewView = null;
            if (peakNavMode) {
                detectPeaks();
                autoCreateIntervalsFromPeaks();
                if (peaks.length > 0) { currentPeak = 0; updatePeakLabel(); }
            }
            if (fastPreviewMode) { computeJSBaseline(); }
            else { renderAll(); scheduleAutoPreview(); }
        } else {
            requestSpectrum(currentSignal);
        }
        updateSignalIndexLabel();
        updateLegendSwatches();
    }
}

function requestSpectrum(idx) {
    sendAction('getSpectrum', { signalIndex: idx });
}

/* ====================================================================
   PER-SIGNAL MODE
   ==================================================================== */
function onPerSignalChanged() {
    if (perSignalMode) {
        if (!signalMode) {
            signalMode = true;
            onSignalModeChanged();
        }
        var gp = getGlobalParams();
        for (var s = 1; s <= nSamples; s++) {
            perSignalIntervals[s] = JSON.parse(JSON.stringify(intervals));
            perSignalGlobalParams[s] = { lambda: gp.lambda, p: gp.p, mu: gp.mu };
        }
        setStatus('success', 'Per-signal mode ON. Current params copied to all signals.');
    } else {
        saveCurrentSignalParams();
        intervals = perSignalIntervals[1] ? JSON.parse(JSON.stringify(perSignalIntervals[1])) : [];
        var gp1 = perSignalGlobalParams[1] || getGlobalParams();
        setSliderVal('lambda', gp1.lambda);
        setSliderVal('mu', gp1.mu);
        setPSliderVal('p', gp1.p);
        selectedIdx = -1;
        updateSelectedIntervalPanel();
        updateIntervalTable();
        setStatus('success', 'Global mode ON. Using signal 1 params.');
    }
    updateBurgerChecks();
    renderAll();
}

function saveCurrentSignalParams() {
    if (!perSignalMode) return;
    perSignalIntervals[currentSignal] = JSON.parse(JSON.stringify(intervals));
    var gp = getGlobalParams();
    perSignalGlobalParams[currentSignal] = { lambda: gp.lambda, p: gp.p, mu: gp.mu };
}

function loadCurrentSignalParams() {
    if (!perSignalMode) return;
    intervals = perSignalIntervals[currentSignal] ? JSON.parse(JSON.stringify(perSignalIntervals[currentSignal])) : [];
    var gp = perSignalGlobalParams[currentSignal] || getGlobalParams();
    setSliderVal('lambda', gp.lambda);
    setSliderVal('mu', gp.mu);
    setPSliderVal('p', gp.p);
    selectedIdx = -1;
    updateSelectedIntervalPanel();
    updateIntervalTable();
}

function setSliderVal(param, v) {
    v = Math.max(1e-10, v);
    document.getElementById('val-' + param).value = fmtNum(v);
    document.getElementById('slider-' + param).value = Math.log10(v);
}
function setPSliderVal(param, v) {
    document.getElementById('val-' + param).value = v.toFixed(4);
    document.getElementById('slider-' + param).value = v;
}

/* ====================================================================
   SHOW ALL
   ==================================================================== */
function onShowAllChanged() {
    updateBurgerChecks();
    renderAll();
    scheduleAutoPreview();
}

/* ====================================================================
   INTERVAL MANAGEMENT
   ==================================================================== */
function checkIntervalOverlap(s, e, excludeIdx) {
    // Check if [s, e] overlaps with any existing interval (excluding excludeIdx)
    for (var i = 0; i < intervals.length; i++) {
        if (i === excludeIdx) continue;
        var int = intervals[i];
        // Overlap if: s <= int.endIdx AND e >= int.startIdx
        if (s <= int.endIdx && e >= int.startIdx) {
            return i; // Return index of overlapping interval
        }
    }
    return -1; // No overlap
}

function adjustIntervalToFit(s, e, minWidth) {
    // Adjust interval [s, e] to avoid overlaps, returns null if can't fit
    minWidth = minWidth || 3;
    var adjusted = { s: s, e: e };

    // Collect all existing interval boundaries
    var blocked = [];
    for (var i = 0; i < intervals.length; i++) {
        blocked.push({ start: intervals[i].startIdx, end: intervals[i].endIdx });
    }
    blocked.sort(function(a, b) { return a.start - b.start; });

    // Check each overlapping interval and shrink our interval
    for (var i = 0; i < blocked.length; i++) {
        var b = blocked[i];
        // If no overlap, continue
        if (adjusted.e < b.start || adjusted.s > b.end) continue;

        // Overlap detected - decide which side to shrink
        var centerNew = (adjusted.s + adjusted.e) / 2;
        var centerBlocked = (b.start + b.end) / 2;

        if (centerNew < centerBlocked) {
            // New interval is more to the left, shrink from right
            adjusted.e = Math.min(adjusted.e, b.start - 1);
        } else {
            // New interval is more to the right, shrink from left
            adjusted.s = Math.max(adjusted.s, b.end + 1);
        }
    }

    // Check if result is valid
    if (adjusted.e - adjusted.s < minWidth) return null;
    return adjusted;
}

function addIntervalFromDraw(startX, endX) {
    var s = xValToIdx(Math.min(startX, endX));
    var e = xValToIdx(Math.max(startX, endX));
    s = Math.max(1, Math.min(nChannels, s));
    e = Math.max(1, Math.min(nChannels, e));
    if (e - s < 2) e = Math.min(nChannels, s + 3);

    // Adjust to fit if overlapping
    var fit = adjustIntervalToFit(s, e, 3);
    if (!fit) return; // Can't fit
    s = fit.s;
    e = fit.e;

    var defLam = parseFloat(document.getElementById('val-lambda').value) || 100000;
    var defP = parseFloat(document.getElementById('val-p-in').value) || 0.001;
    intervals.push({ startIdx: s, endIdx: e, lambda: defLam, p: defP });
    selectedIdx = intervals.length - 1;
    updateSelectedIntervalPanel();
    updateIntervalTable();
    /* Auto-switch to interval tab when drawing */
    switchTab('interval');
    renderAll();
    scheduleAutoPreview();
    setStatus('success', 'Interval ' + intervals.length + ' added: [' + fmtNum(idxToXVal(s)) + ', ' + fmtNum(idxToXVal(e)) + ']');
}

function deleteSelectedIntervals() {
    if (selectedIdx < 0 || selectedIdx >= intervals.length) return;
    // Use removeInterval which also handles peak cleanup
    removeInterval(selectedIdx);
}

function clearIntervals() {
    intervals = [];
    selectedIdx = -1;

    // Also clear peaks and reset peak detection mode
    peaks = [];
    peaksEnabled = false;
    peakNavMode = false;
    currentPeak = -1;
    document.getElementById('badge-detect-peaks').classList.remove('active');
    document.getElementById('peak-section').style.display = 'none';

    updateSelectedIntervalPanel();
    updateIntervalTable();
    renderAll();
    scheduleAutoPreview();
    setStatus('success', 'All intervals cleared');
}

function selectInterval(idx) {
    selectedIdx = idx;
    updateSelectedIntervalPanel();
    updateIntervalTable();
    switchTab('interval');
    renderAll();
}

function updateSelectedIntervalPanel() {
    var panel = document.getElementById('selected-interval-panel');
    var placeholder = document.getElementById('interval-no-selection');
    var delBtn = document.getElementById('btn-delete-selected');
    if (selectedIdx >= 0 && selectedIdx < intervals.length) {
        panel.style.display = 'block';
        placeholder.style.display = 'none';
        delBtn.disabled = false;
        var intv = intervals[selectedIdx];
        document.getElementById('selected-info').textContent =
            'Selected: Int ' + (selectedIdx+1) + '  [' + fmtNum(idxToXVal(intv.startIdx)) + ' \u2013 ' + fmtNum(idxToXVal(intv.endIdx)) + ']';
        document.getElementById('val-lambda-in').value = fmtNum(intv.lambda);
        // Auto-expand lambda slider range if value is out of range
        var lamLog = (intv.lambda === 0) ? sliderCfg.lambdaIn.min : Math.log10(intv.lambda);
        if (lamLog > sliderCfg.lambdaIn.max) sliderCfg.lambdaIn.max = Math.ceil(lamLog);
        var slLam = document.getElementById('slider-lambda-in');
        slLam.min = sliderCfg.lambdaIn.min; slLam.max = sliderCfg.lambdaIn.max;
        slLam.value = lamLog;
        // Auto-expand p slider range if value is out of range
        var pInSlider = document.getElementById('slider-p-in');
        if (intv.p > pCfg.pIn.max) {
            pCfg.pIn.max = Math.min(1, intv.p * 2);
            pInSlider.max = pCfg.pIn.max;
        }
        document.getElementById('val-p-in').value = intv.p.toFixed(4);
        pInSlider.min = pCfg.pIn.min; pInSlider.max = pCfg.pIn.max; pInSlider.step = pCfg.pIn.step;
        pInSlider.value = intv.p;
    } else {
        panel.style.display = 'none';
        placeholder.style.display = 'block';
        delBtn.disabled = true;
    }
}

function resetIntervalToGlobal() {
    if (selectedIdx < 0 || selectedIdx >= intervals.length) return;
    var gp = getGlobalParams();
    intervals[selectedIdx].lambda = gp.lambda;
    intervals[selectedIdx].p = 0.001;
    updateSelectedIntervalPanel();
    updateIntervalTable();
    renderAll();
    scheduleAutoPreview();
    setStatus('success', 'Interval ' + (selectedIdx+1) + ' reset to global defaults');
}

function resetGlobalDefaults() {
    // Reset values
    document.getElementById('val-lambda').value = '100000';
    document.getElementById('val-p').value = '0.001';
    document.getElementById('val-mu').value = '0';
    // Reset slider ranges to defaults
    sliderCfg.lambda.min = -3; sliderCfg.lambda.max = 8;
    sliderCfg.mu.min = -3; sliderCfg.mu.max = 6;
    pCfg.p.min = 0; pCfg.p.max = 1; pCfg.p.step = 0.01;
    var slL = document.getElementById('slider-lambda'); slL.min = -3; slL.max = 8;
    var slP = document.getElementById('slider-p'); slP.min = 0; slP.max = 1; slP.step = 0.01;
    var slM = document.getElementById('slider-mu'); slM.min = -3; slM.max = 6;
    // Move sliders to default positions
    slL.value = 5;   // log10(100000) = 5
    slP.value = 0.001;
    slM.value = -3;  // 0 (leftmost position)
    initAllTicks();
    renderAll();
    scheduleAutoPreview();
    setStatus('success', 'Global parameters reset to defaults');
}

/* ====================================================================
   INTERVAL TABLE (READ-ONLY - click to select, use chart to edit)
   ==================================================================== */
var tableSortColumn = 'index';
var tableSortAsc = true;
var tableSortOrder = null; // maps display index -> intervals array index

function sortIntervalTable(column) {
    if (tableSortColumn === column) {
        tableSortAsc = !tableSortAsc;
    } else {
        tableSortColumn = column;
        tableSortAsc = true;
    }
    updateIntervalTable();
}

function getIntervalSortOrder() {
    var indices = [];
    for (var i = 0; i < intervals.length; i++) indices.push(i);
    var col = tableSortColumn;
    var asc = tableSortAsc;

    indices.sort(function(a, b) {
        var va, vb;
        switch (col) {
            case 'index': va = a; vb = b; break;
            case 'start': va = intervals[a].startIdx; vb = intervals[b].startIdx; break;
            case 'end': va = intervals[a].endIdx; vb = intervals[b].endIdx; break;
            case 'width': va = intervals[a].endIdx - intervals[a].startIdx; vb = intervals[b].endIdx - intervals[b].startIdx; break;
            case 'lambda': va = intervals[a].lambda; vb = intervals[b].lambda; break;
            case 'p': va = intervals[a].p; vb = intervals[b].p; break;
            case 'area': va = intervals[a]._area || 0; vb = intervals[b]._area || 0; break;
            case 'max': va = intervals[a]._max || 0; vb = intervals[b]._max || 0; break;
            case 'min': va = intervals[a]._min || 0; vb = intervals[b]._min || 0; break;
            default: va = a; vb = b;
        }
        return asc ? (va - vb) : (vb - va);
    });
    return indices;
}

function updateIntervalTable() {
    var tbody = document.getElementById('intervals-tbody');
    var wrap = document.getElementById('intervals-table-wrap');
    tbody.innerHTML = '';
    if (intervals.length === 0) { wrap.style.display = 'none'; tableSortOrder = null; return; }
    wrap.style.display = 'block';

    tableSortOrder = getIntervalSortOrder();

    // Update sort arrow indicators in header
    var ths = wrap.querySelectorAll('th');
    var colNames = ['index','start','end','width','lambda','p','area','max','min'];
    for (var t = 0; t < colNames.length; t++) {
        if (t >= ths.length) break;
        ths[t].classList.remove('sort-active');
        var arrow = ths[t].querySelector('.sort-arrow');
        if (arrow) arrow.innerHTML = '&#9650;';
        if (colNames[t] === tableSortColumn) {
            ths[t].classList.add('sort-active');
            if (arrow) arrow.innerHTML = tableSortAsc ? '&#9650;' : '&#9660;';
        }
    }

    for (var di = 0; di < tableSortOrder.length; di++) {
        var i = tableSortOrder[di];
        var v = intervals[i];
        var sVal = idxToXVal(v.startIdx);
        var eVal = idxToXVal(v.endIdx);
        var wVal = eVal - sVal;
        var area = v._area !== undefined ? v._area.toFixed(1) : '-';
        var mx = v._max !== undefined ? v._max.toFixed(2) : '-';
        var mn = v._min !== undefined ? v._min.toFixed(2) : '-';
        var tr = document.createElement('tr');
        tr.style.cursor = 'pointer';
        tr.onclick = function(idx) { return function() { selectInterval(idx); }; }(i);
        tr.innerHTML =
            '<td>' + (i+1) + '</td>' +
            '<td>' + fmtNum(sVal) + '</td>' +
            '<td>' + fmtNum(eVal) + '</td>' +
            '<td>' + fmtNum(wVal) + '</td>' +
            '<td>' + fmtNum(v.lambda) + '</td>' +
            '<td>' + v.p.toFixed(4) + '</td>' +
            '<td>' + area + '</td><td>' + mx + '</td><td>' + mn + '</td>' +
            '<td><button class="btn-remove-interval" onclick="event.stopPropagation(); removeInterval(' + i + ')">&times;</button></td>';
        if (i === selectedIdx) tr.classList.add('selected');
        tbody.appendChild(tr);
    }
}

function removeInterval(idx) {
    // Get interval range before removing
    var intv = intervals[idx];
    var start = intv.startIdx;
    var end = intv.endIdx;

    intervals.splice(idx, 1);
    if (selectedIdx >= intervals.length) selectedIdx = intervals.length - 1;
    if (selectedIdx === idx) selectedIdx = -1;

    // Also remove any peaks that fall within this interval's range
    var startX = idxToXVal(start), endX = idxToXVal(end);
    if (peaks.length > 0) {
        peaks = peaks.filter(function(pk) {
            return pk.x < startX || pk.x > endX;
        });
        // Update peak section visibility
        if (peaks.length === 0) {
            peaksEnabled = false;
            peakNavMode = false;
            currentPeak = -1;
            document.getElementById('badge-detect-peaks').classList.remove('active');
            document.getElementById('peak-section').style.display = 'none';
        } else {
            currentPeak = Math.min(currentPeak, peaks.length - 1);
            document.getElementById('peak-label').textContent =
                'Peak ' + (currentPeak + 1) + '/' + peaks.length;
        }
    }

    updateSelectedIntervalPanel();
    updateIntervalTable();
    renderAll();
    scheduleAutoPreview();
}

/* ====================================================================
   INTERVAL DRAWING ON CANVAS
   ==================================================================== */
function startDrawInterval() {
    if (currentSpectrum.length === 0) return;
    drawingMode = true;
    drawStart = null;
    drawCurrent = null;
    document.getElementById('preview-wrapper').classList.add('drawing-mode');
    setStatus('processing', 'Click and drag on preview to draw interval...');
}

function canvasXToData(canvas, clientX) {
    var rect = canvas.getBoundingClientRect();
    var mx = clientX - rect.left;
    var pw = rect.width - MARGIN.left - MARGIN.right;
    var view = previewView || getAutoView('preview');
    var frac = (mx - MARGIN.left) / pw;
    return view.xMin + frac * (view.xMax - view.xMin);
}

/* Convert x-axis value to 1-based array index (nearest match) */
function xValToIdx(xVal) {
    if (!wavelength || wavelength.length === 0) return Math.round(xVal);
    // Binary search for nearest wavelength value
    var lo = 0, hi = wavelength.length - 1;
    while (lo < hi) {
        var mid = Math.floor((lo + hi) / 2);
        if (wavelength[mid] < xVal) lo = mid + 1;
        else hi = mid;
    }
    // Check if lo-1 is closer
    if (lo > 0 && Math.abs(wavelength[lo - 1] - xVal) < Math.abs(wavelength[lo] - xVal)) lo--;
    return lo + 1; // 1-based index
}

/* Convert 1-based array index to x-axis value */
function idxToXVal(idx) {
    if (!wavelength || wavelength.length === 0) return idx;
    var i = Math.max(0, Math.min(wavelength.length - 1, idx - 1));
    return wavelength[i];
}

/* ====================================================================
   PEAK DETECTION (JS - toolbox-free findpeaks)
   ==================================================================== */
function detectPeaks() {
    if (currentSpectrum.length < 5) return;
    peaksEnabled = true;
    var y = currentSpectrum;
    var n = y.length;
    var rng = Math.max.apply(null, y) - Math.min.apply(null, y);
    if (rng <= 0) rng = 1;
    var minProm = peakMinProminence * rng;
    var minDist = (peakMinDistance > 0) ? peakMinDistance : Math.max(5, Math.round(n / 60));

    var w = 5, hw = Math.floor(w/2);
    var ys = new Array(n);
    for (var i = 0; i < n; i++) {
        var s = 0, c = 0;
        for (var j = Math.max(0, i-hw); j <= Math.min(n-1, i+hw); j++) { s += y[j]; c++; }
        ys[i] = s / c;
    }

    var cands = [];
    for (var i = 1; i < n-1; i++) {
        if ((ys[i] > ys[i-1] && ys[i] >= ys[i+1]) || (ys[i] >= ys[i-1] && ys[i] > ys[i+1])) {
            var leftMin = ys[i], j = i;
            while (j > 0 && ys[j-1] <= ys[i]) { j--; leftMin = Math.min(leftMin, ys[j]); }
            var rightMin = ys[i]; j = i;
            while (j < n-1 && ys[j+1] <= ys[i]) { j++; rightMin = Math.min(rightMin, ys[j]); }
            var prom = ys[i] - Math.max(leftMin, rightMin);
            if (prom >= minProm) cands.push({ idx: i, x: wavelength[i] || (i+1), prom: prom, val: ys[i] });
        }
    }

    cands.sort(function(a,b) { return b.val - a.val; });
    var taken = {};
    peaks = [];
    for (var i = 0; i < cands.length; i++) {
        if (taken[cands[i].idx]) continue;
        peaks.push(cands[i]);
        for (var j = 0; j < cands.length; j++) {
            if (Math.abs(cands[j].idx - cands[i].idx) < minDist) taken[cands[j].idx] = true;
        }
    }
    peaks.sort(function(a,b) { return a.x - b.x; });

    for (var i = 0; i < peaks.length; i++) {
        var pk = peaks[i];
        // Find peak base via valley-to-valley: descend each side until a sustained
        // local minimum or until we drop below 5% of prominence above the floor.
        // Use a lookahead window to avoid stopping at single-point noise reversals.
        var threshold = ys[pk.idx] - 0.95 * pk.prom;
        var lookAhead = Math.max(3, Math.round(n / 200)); // points to confirm a valley

        // Left boundary
        var jl = pk.idx;
        while (jl > 0) {
            if (ys[jl - 1] <= threshold) { jl--; break; }
            // Check if this is a true valley: the next 'lookAhead' points don't go lower
            var isValley = true;
            for (var k = 1; k <= lookAhead && jl - k >= 0; k++) {
                if (ys[jl - k] < ys[jl]) { isValley = false; break; }
            }
            if (isValley && jl < pk.idx) break;
            jl--;
        }
        // Right boundary
        var jr = pk.idx;
        while (jr < n - 1) {
            if (ys[jr + 1] <= threshold) { jr++; break; }
            var isValley = true;
            for (var k = 1; k <= lookAhead && jr + k < n; k++) {
                if (ys[jr + k] < ys[jr]) { isValley = false; break; }
            }
            if (isValley && jr > pk.idx) break;
            jr++;
        }
        pk.baseL = jl;
        pk.baseR = jr;
        pk.width = (wavelength[jr] || jr + 1) - (wavelength[jl] || jl + 1);
    }

    var peakSection = document.getElementById('peak-section');
    if (peaks.length > 0) {
        currentPeak = 0;
        peakSection.style.display = 'block';
        document.getElementById('btn-prev-peak').disabled = false;
        document.getElementById('btn-next-peak').disabled = false;
        updatePeakLabel();
        // Start peak glow animation
        animatePeaksAppearing();
    } else {
        currentPeak = -1;
        peakSection.style.display = 'block';
        document.getElementById('btn-prev-peak').disabled = true;
        document.getElementById('btn-next-peak').disabled = true;
        document.getElementById('peak-label').textContent = 'No peaks found';
        renderAll();
    }
}

function animatePeaksAppearing() {
    // Cancel existing animation
    if (peakAnimationFrame) {
        cancelAnimationFrame(peakAnimationFrame);
        peakAnimationFrame = null;
    }

    // Initialize glow state - all peaks start invisible
    peakGlowState = [];
    for (var i = 0; i < peaks.length; i++) {
        peakGlowState.push({ appear: 0, glow: 0 });
    }

    peakAnimationStart = performance.now();
    runPeakAnimation();
}

function runPeakAnimation() {
    var now = performance.now();
    var elapsed = now - peakAnimationStart;
    var allDone = true;

    // Animation timing
    var appearDelay = 40;  // ms between each peak appearing
    var appearDuration = 150;  // ms for fade-in
    var glowDuration = 600;  // ms for glow pulse

    for (var i = 0; i < peaks.length; i++) {
        var peakStart = i * appearDelay;
        var peakElapsed = elapsed - peakStart;

        if (peakElapsed < 0) {
            // Not started yet
            peakGlowState[i].appear = 0;
            peakGlowState[i].glow = 0;
            allDone = false;
        } else if (peakElapsed < appearDuration) {
            // Appearing
            peakGlowState[i].appear = peakElapsed / appearDuration;
            peakGlowState[i].glow = 1;
            allDone = false;
        } else if (peakElapsed < appearDuration + glowDuration) {
            // Glow fading
            peakGlowState[i].appear = 1;
            var glowElapsed = peakElapsed - appearDuration;
            peakGlowState[i].glow = 1 - (glowElapsed / glowDuration);
            allDone = false;
        } else {
            // Done
            peakGlowState[i].appear = 1;
            peakGlowState[i].glow = 0;
        }
    }

    renderPreviewChart();

    if (!allDone) {
        peakAnimationFrame = requestAnimationFrame(runPeakAnimation);
    } else {
        peakAnimationFrame = null;
    }
}

function stepPeak(dir) {
    if (peaks.length === 0) return;
    currentPeak = Math.max(0, Math.min(peaks.length - 1, currentPeak + dir));
    updatePeakLabel();
    zoomToPeak(currentPeak);
}

function updatePeakLabel() {
    document.getElementById('peak-label').textContent = peaks.length > 0 ?
        ('Peak ' + (currentPeak+1) + '/' + peaks.length) : '';
}

function zoomToPeak(k) {
    if (k < 0 || k >= peaks.length) return;
    var xc = peaks[k].x;
    var halfWin = Math.max(10, Math.round(2.5 * (peaks[k].width || 20)));
    var x1 = Math.max(wavelength[0], xc - halfWin);
    var x2 = Math.min(wavelength[wavelength.length-1], xc + halfWin);

    // Compute Y range only for data within this X interval
    var yr = getDataRangeInInterval(x1, x2);
    previewView = { xMin: x1, xMax: x2, yMin: yr.min, yMax: yr.max };
    renderPreviewChart();
}

function getDataRangeInInterval(xMin, xMax) {
    var yMin = Infinity, yMax = -Infinity;

    // Find indices for the X range
    var i1 = 0, i2 = wavelength.length - 1;
    for (var i = 0; i < wavelength.length; i++) {
        if (wavelength[i] >= xMin) { i1 = i; break; }
    }
    for (var i = wavelength.length - 1; i >= 0; i--) {
        if (wavelength[i] <= xMax) { i2 = i; break; }
    }

    // Get Y range for spectrum in this interval
    for (var i = i1; i <= i2; i++) {
        if (currentSpectrum[i] < yMin) yMin = currentSpectrum[i];
        if (currentSpectrum[i] > yMax) yMax = currentSpectrum[i];
    }

    // Include baseline data if available
    if (baselineData.length > 0) {
        for (var i = i1; i <= i2; i++) {
            if (baselineData[i] < yMin) yMin = baselineData[i];
            if (baselineData[i] > yMax) yMax = baselineData[i];
        }
    }

    // Add padding
    var pad = (yMax - yMin) * 0.1;
    return { min: yMin - pad, max: yMax + pad };
}

/* ====================================================================
   BADGE FUNCTIONS (chart overlay buttons)
   ==================================================================== */
var peakNavMode = false;

function togglePeakDetection() {
    var badge = document.getElementById('badge-detect-peaks');

    if (peakNavMode) {
        // Turn off peak detection mode
        peakNavMode = false;
        peaksEnabled = false;
        peaks = [];
        currentPeak = -1;
        badge.classList.remove('active');
        document.getElementById('peak-section').style.display = 'none';
        previewView = null; // Reset zoom
        setStatus('idle', 'Peak detection disabled');
    } else {
        // Turn on peak detection mode - only for current displayed spectrum
        if (currentSpectrum.length < 5) {
            setStatus('error', 'No data loaded for peak detection');
            return;
        }
        peakNavMode = true;
        badge.classList.add('active');

        // Detect peaks only on current spectrum (could be a single sample, current signal, or mean)
        detectPeaks();
        autoCreateIntervalsFromPeaks();
        var spectrumType = signalMode ? ('signal ' + currentSignal) : (nSamples > 1 ? 'mean spectrum' : 'spectrum');
        setStatus('success', 'Peak detection on ' + spectrumType + '. ' + peaks.length + ' peaks found.');
    }
    updateBurgerChecks();
    renderAll();
}

function applyPeakDetectionToAllSamples() {
    // Check if allSpectra is available
    if (!allSpectra || allSpectra.length === 0) {
        setStatus('error', 'All spectra data not loaded. Cannot apply to all samples.');
        // Fall back to current signal only
        detectPeaks();
        autoCreateIntervalsFromPeaks();
        setStatus('success', 'Peak detection enabled for current signal. ' + peaks.length + ' peaks found.');
        return;
    }

    // Enable signal-by-signal and per-signal modes
    if (!signalMode) {
        signalMode = true;
        updateSignalNav();
        showAllSpectra = false;
    }
    if (!perSignalMode) {
        perSignalMode = true;
    }
    updateBurgerChecks();

    // Get global params for default
    var gp = getGlobalParams();

    // Process each sample
    var totalPeaks = 0;
    var totalIntervals = 0;
    for (var s = 1; s <= nSamples; s++) {
        var spectrum = allSpectra[s - 1];
        if (!spectrum || spectrum.length < 5) continue;
        var samplePeaks = detectPeaksInSpectrum(spectrum);
        var sampleIntervals = createIntervalsFromPeaks(samplePeaks);
        perSignalIntervals[s] = sampleIntervals;
        perSignalGlobalParams[s] = { lambda: gp.lambda, p: gp.p, mu: gp.mu };
        totalPeaks += samplePeaks.length;
        totalIntervals += sampleIntervals.length;
    }

    // Set current signal and load its data
    currentSignal = 1;
    currentSpectrum = allSpectra[0].slice();
    intervals = perSignalIntervals[1] ? JSON.parse(JSON.stringify(perSignalIntervals[1])) : [];
    selectedIdx = -1;

    // Detect peaks for display on current signal
    detectPeaks();

    updateSelectedIntervalPanel();
    updateIntervalTable();
    setStatus('success', 'Applied peak detection to all ' + nSamples + ' samples. Total: ' + totalIntervals + ' intervals');
}

function detectPeaksInSpectrum(y) {
    if (!y || y.length < 5) return [];
    var n = y.length;
    var rng = Math.max.apply(null, y) - Math.min.apply(null, y);
    if (rng <= 0) rng = 1;
    var minProm = peakMinProminence * rng;
    var minDist = (peakMinDistance > 0) ? peakMinDistance : Math.max(5, Math.round(n / 60));

    var w = 5, hw = Math.floor(w/2);
    var ys = new Array(n);
    for (var i = 0; i < n; i++) {
        var s = 0, c = 0;
        for (var j = Math.max(0, i-hw); j <= Math.min(n-1, i+hw); j++) { s += y[j]; c++; }
        ys[i] = s / c;
    }

    var cands = [];
    for (var i = 1; i < n-1; i++) {
        if ((ys[i] > ys[i-1] && ys[i] >= ys[i+1]) || (ys[i] >= ys[i-1] && ys[i] > ys[i+1])) {
            var leftMin = ys[i], j = i;
            while (j > 0 && ys[j-1] <= ys[i]) { j--; leftMin = Math.min(leftMin, ys[j]); }
            var rightMin = ys[i]; j = i;
            while (j < n-1 && ys[j+1] <= ys[i]) { j++; rightMin = Math.min(rightMin, ys[j]); }
            var prom = ys[i] - Math.max(leftMin, rightMin);
            if (prom >= minProm) cands.push({ idx: i, x: wavelength[i] || (i+1), prom: prom, val: ys[i] });
        }
    }

    cands.sort(function(a,b) { return b.val - a.val; });
    var taken = {};
    var foundPeaks = [];
    for (var i = 0; i < cands.length; i++) {
        if (taken[cands[i].idx]) continue;
        foundPeaks.push(cands[i]);
        for (var j = 0; j < cands.length; j++) {
            if (Math.abs(cands[j].idx - cands[i].idx) < minDist) taken[cands[j].idx] = true;
        }
    }
    foundPeaks.sort(function(a,b) { return a.x - b.x; });

    // Calculate peak base boundaries (valley-to-valley with lookahead or 5% prominence threshold)
    var lookAhead = Math.max(3, Math.round(n / 200));
    for (var i = 0; i < foundPeaks.length; i++) {
        var pk = foundPeaks[i];
        var threshold = ys[pk.idx] - 0.95 * pk.prom;
        var jl = pk.idx;
        while (jl > 0) {
            if (ys[jl - 1] <= threshold) { jl--; break; }
            var isValley = true;
            for (var k = 1; k <= lookAhead && jl - k >= 0; k++) {
                if (ys[jl - k] < ys[jl]) { isValley = false; break; }
            }
            if (isValley && jl < pk.idx) break;
            jl--;
        }
        var jr = pk.idx;
        while (jr < n - 1) {
            if (ys[jr + 1] <= threshold) { jr++; break; }
            var isValley = true;
            for (var k = 1; k <= lookAhead && jr + k < n; k++) {
                if (ys[jr + k] < ys[jr]) { isValley = false; break; }
            }
            if (isValley && jr > pk.idx) break;
            jr++;
        }
        pk.baseL = jl;
        pk.baseR = jr;
        pk.width = (wavelength[jr] || jr + 1) - (wavelength[jl] || jl + 1);
    }

    return foundPeaks;
}

function createIntervalsFromPeaks(peakList) {
    if (!peakList || peakList.length === 0) return [];

    var spacing = (wavelength.length > 1) ? Math.abs(wavelength[1] - wavelength[0]) : 1;
    var marginPts = 3; // extra points beyond the base
    var newIntervals = [];
    for (var i = 0; i < peakList.length; i++) {
        var pk = peakList[i];
        // Use valley-to-valley base if available, otherwise fall back to width estimate
        var startIdx, endIdx;
        if (pk.baseL !== undefined && pk.baseR !== undefined) {
            startIdx = Math.max(1, pk.baseL + 1 - marginPts); // baseL is 0-based, convert to 1-based
            endIdx = Math.min(wavelength.length, pk.baseR + 1 + marginPts);
        } else {
            var widthX = pk.width || 20;
            var halfW = widthX / 2;
            var marginX = Math.max(halfW * 0.3, marginPts * spacing);
            startIdx = Math.max(1, xValToIdx(pk.x - halfW - marginX));
            endIdx = Math.min(wavelength.length, xValToIdx(pk.x + halfW + marginX));
        }

        if (endIdx - startIdx >= 3) {
            newIntervals.push({
                startIdx: startIdx,
                endIdx: endIdx,
                lambda: 100000,
                p: 0.001
            });
        }
    }

    // Merge overlapping intervals
    if (newIntervals.length > 1) {
        newIntervals.sort(function(a, b) { return a.startIdx - b.startIdx; });
        var merged = [newIntervals[0]];
        for (var i = 1; i < newIntervals.length; i++) {
            var last = merged[merged.length - 1];
            if (newIntervals[i].startIdx <= last.endIdx + 5) {
                last.endIdx = Math.max(last.endIdx, newIntervals[i].endIdx);
            } else {
                merged.push(newIntervals[i]);
            }
        }
        newIntervals = merged;
    }

    return newIntervals;
}

function autoCreateIntervalsFromPeaks() {
    if (peaks.length === 0) return;

    // Clear existing intervals
    intervals = [];
    selectedIdx = -1;

    // Build all intervals first (without adding to the array yet)
    var marginPts = 3;
    var newIntervals = [];
    for (var i = 0; i < peaks.length; i++) {
        var pk = peaks[i];
        var startIdx, endIdx;
        if (pk.baseL !== undefined && pk.baseR !== undefined) {
            startIdx = Math.max(1, pk.baseL + 1 - marginPts);
            endIdx = Math.min(wavelength.length, pk.baseR + 1 + marginPts);
        } else {
            var widthX = pk.width || 20;
            var halfW = widthX / 2;
            var spacing = (wavelength.length > 1) ? Math.abs(wavelength[1] - wavelength[0]) : 1;
            var marginX = Math.max(halfW * 0.3, marginPts * spacing);
            startIdx = Math.max(1, xValToIdx(pk.x - halfW - marginX));
            endIdx = Math.min(wavelength.length, xValToIdx(pk.x + halfW + marginX));
        }

        if (endIdx - startIdx >= 3) {
            newIntervals.push({
                startIdx: startIdx,
                endIdx: endIdx,
                lambda: 100000,  // Default lambda inside interval
                p: 0.001         // Low p for better peak fitting
            });
        }
    }

    // Merge overlapping intervals in the temp array
    if (newIntervals.length > 1) {
        newIntervals.sort(function(a, b) { return a.startIdx - b.startIdx; });
        var merged = [newIntervals[0]];
        for (var i = 1; i < newIntervals.length; i++) {
            var last = merged[merged.length - 1];
            if (newIntervals[i].startIdx <= last.endIdx + 5) {
                last.endIdx = Math.max(last.endIdx, newIntervals[i].endIdx);
            } else {
                merged.push(newIntervals[i]);
            }
        }
        newIntervals = merged;
    }

    // Animate intervals appearing one by one
    animateIntervalsAppearing(newIntervals);
}

var intervalAnimationTimer = null;

function animateIntervalsAppearing(newIntervals) {
    // Clear any existing animation
    if (intervalAnimationTimer) {
        clearTimeout(intervalAnimationTimer);
        intervalAnimationTimer = null;
    }

    intervals = [];
    var idx = 0;
    var delay = Math.min(80, 600 / Math.max(1, newIntervals.length)); // Faster with more intervals

    function addNextInterval() {
        if (idx < newIntervals.length) {
            intervals.push(newIntervals[idx]);
            idx++;
            updateIntervalTable();
            renderPreviewChart();
            intervalAnimationTimer = setTimeout(addNextInterval, delay);
        } else {
            // Animation complete
            intervalAnimationTimer = null;
            scheduleAutoPreview();
            setStatus('success', 'Created ' + intervals.length + ' intervals from ' + peaks.length + ' peaks');
        }
    }

    addNextInterval();
}

function mergeOverlappingIntervals() {
    if (intervals.length <= 1) return;
    intervals.sort(function(a, b) { return a.startIdx - b.startIdx; });

    var merged = [intervals[0]];
    for (var i = 1; i < intervals.length; i++) {
        var last = merged[merged.length - 1];
        if (intervals[i].startIdx <= last.endIdx + 5) {
            // Merge: extend the end
            last.endIdx = Math.max(last.endIdx, intervals[i].endIdx);
        } else {
            merged.push(intervals[i]);
        }
    }
    intervals = merged;
}

/* ====================================================================
   INTERVAL METRICS
   ==================================================================== */
function computeIntervalMetrics() {
    if (currentSpectrum.length === 0 || baselineData.length === 0) return;
    var corrected = [];
    for (var i = 0; i < currentSpectrum.length; i++) corrected.push(currentSpectrum[i] - baselineData[i]);
    for (var k = 0; k < intervals.length; k++) {
        var s = Math.max(0, intervals[k].startIdx - 1);
        var e = Math.min(corrected.length - 1, intervals[k].endIdx - 1);
        if (e <= s) { intervals[k]._area = 0; intervals[k]._max = 0; intervals[k]._min = 0; continue; }
        var seg = corrected.slice(s, e + 1);
        var area = 0;
        for (var i = 0; i < seg.length - 1; i++) area += (seg[i] + seg[i+1]) / 2;
        intervals[k]._area = area;
        intervals[k]._max = Math.max.apply(null, seg);
        intervals[k]._min = Math.min.apply(null, seg);
    }
}

/* ====================================================================
   SOLVER / SLIDER SETTINGS / HELP (MODALS)
   ==================================================================== */
function openSolverSettings() {
    showModal('Solver Settings', [
        { label: 'Max Iterations', id: 'modal-maxiter', type: 'number', value: solverMaxIter, min: 1, max: 5000 },
        { label: 'Tolerance', id: 'modal-tol', type: 'number', value: solverTol, min: 0, max: 1, step: 0.000001 }
    ], function() {
        solverMaxIter = parseInt(document.getElementById('modal-maxiter').value) || 50;
        solverTol = parseFloat(document.getElementById('modal-tol').value) || 1e-6;
        scheduleAutoPreview();
    });
}

function updateLogTicks(param) {
    var tickIds = { lambda: 'ticks-lambda', mu: 'ticks-mu' };
    var el = document.getElementById(tickIds[param]);
    if (!el) return;
    var cfg = sliderCfg[param];
    var minExp = Math.ceil(cfg.min);
    var maxExp = Math.floor(cfg.max);
    // Generate ~5-6 evenly spaced ticks
    var ticks = [];
    var range = maxExp - minExp;
    var step = Math.max(1, Math.round(range / 5));
    for (var e = minExp; e <= maxExp; e += step) {
        if (cfg.allowZero && e === minExp && minExp < 0) ticks.push('0');
        else if (e === 0) ticks.push('1');
        else if (e === 1) ticks.push('10');
        else ticks.push('10<sup>' + e + '</sup>');
    }
    // Ensure last tick is included
    if (ticks.length > 0) {
        var lastExp = maxExp;
        var lastLabel = lastExp === 0 ? '1' : lastExp === 1 ? '10' : '10<sup>' + lastExp + '</sup>';
        if (ticks[ticks.length - 1] !== lastLabel) ticks.push(lastLabel);
    }
    el.innerHTML = ticks.map(function(t) { return '<span>' + t + '</span>'; }).join('');
}

function updateLinearTicks(param) {
    var tickIds = { p: 'ticks-p' };
    var el = document.getElementById(tickIds[param]);
    if (!el) return;
    var cfg = pCfg[param];
    var mn = cfg.min, mx = cfg.max;
    var range = mx - mn;
    var step = range / 4;
    var ticks = [];
    for (var i = 0; i <= 4; i++) {
        var v = mn + step * i;
        // Format nicely: avoid floating point artifacts
        ticks.push(parseFloat(v.toPrecision(4)).toString());
    }
    el.innerHTML = ticks.map(function(t) { return '<span>' + t + '</span>'; }).join('');
}

function initAllTicks() {
    updateLogTicks('lambda');
    updateLogTicks('mu');
    updateLinearTicks('p');
}

function openSliderSettings(param) {
    var cfg = sliderCfg[param];
    var paramNames = { lambda: '\u03BB (Smoothness)', mu: '\u03BC (Baseline tension)', lambdaIn: '\u03BB inside interval' };
    var displayName = paramNames[param] || param;
    // Convert log10 values to actual values for display (show 0 if allowZero)
    var actualMin = cfg.allowZero ? 0 : Math.pow(10, cfg.min);
    var actualMax = Math.pow(10, cfg.max);
    showModal(displayName + ' Range', [
        { label: 'Minimum value (0 allowed)', id: 'modal-smin', type: 'number', value: actualMin, step: 'any' },
        { label: 'Maximum value', id: 'modal-smax', type: 'number', value: actualMax.toFixed(0), step: 'any' }
    ], function() {
        var mn = parseFloat(document.getElementById('modal-smin').value);
        var mx = parseFloat(document.getElementById('modal-smax').value);
        // Allow min=0 for lambda params (allowZero)
        var minValid = cfg.allowZero ? (mn >= 0) : (mn > 0);
        if (isFinite(mn) && isFinite(mx) && mx > mn && minValid) {
            // Convert actual values back to log10 (keep allowZero min as -3 for 0)
            cfg.min = (mn === 0) ? -3 : Math.log10(mn);
            cfg.max = Math.log10(mx);
            var ids = { lambda: 'slider-lambda', mu: 'slider-mu', lambdaIn: 'slider-lambda-in' };
            var sl = document.getElementById(ids[param]);
            sl.min = cfg.min; sl.max = cfg.max;
            sl.value = Math.max(cfg.min, Math.min(cfg.max, parseFloat(sl.value)));
            updateLogTicks(param);
        }
    });
}

function openPSettings(param) {
    var cfg = pCfg[param];
    var displayNames = { p: 'p (asymmetry)', pIn: 'p\u1D62\u2099 (asymmetry inside)' };
    showModal((displayNames[param] || param) + ' Range', [
        { label: 'Min', id: 'modal-pmin', type: 'number', value: cfg.min, min: 0, max: 1, step: 0.001 },
        { label: 'Max', id: 'modal-pmax', type: 'number', value: cfg.max, min: 0, max: 1, step: 0.001 },
        { label: 'Step', id: 'modal-pstep', type: 'number', value: cfg.step, min: 0, max: 1, step: 0.0001 }
    ], function() {
        var mn = parseFloat(document.getElementById('modal-pmin').value);
        var mx = parseFloat(document.getElementById('modal-pmax').value);
        var st = parseFloat(document.getElementById('modal-pstep').value);
        if (isFinite(mn) && isFinite(mx) && mx > mn && mn >= 0 && mx <= 1) {
            cfg.min = mn; cfg.max = mx; cfg.step = st;
            var ids = { p: 'slider-p', pIn: 'slider-p-in' };
            var sl = document.getElementById(ids[param]);
            sl.min = mn; sl.max = mx; sl.step = st;
            sl.value = Math.max(mn, Math.min(mx, parseFloat(sl.value)));
            updateLinearTicks(param);
        }
    });
}

function openPeakSettings() {
    showModal('Peak Detection Settings', [
        { label: 'Min prominence (% of range)', id: 'modal-peak-prom', type: 'number', value: (peakMinProminence * 100).toFixed(1), min: 0.1, max: 50, step: 0.1 },
        { label: 'Min distance (0 = auto)', id: 'modal-peak-dist', type: 'number', value: peakMinDistance, min: 0, max: 500, step: 1 }
    ], function() {
        var prom = parseFloat(document.getElementById('modal-peak-prom').value);
        var dist = parseInt(document.getElementById('modal-peak-dist').value);
        if (isFinite(prom) && prom >= 0.1 && prom <= 50) {
            peakMinProminence = prom / 100;
        }
        if (isFinite(dist) && dist >= 0) {
            peakMinDistance = dist;
        }
        // Re-run peak detection and recreate intervals if peaks are enabled
        if (peaksEnabled && currentSpectrum.length > 0) {
            detectPeaks();
            autoCreateIntervalsFromPeaks();
            updateIntervalTable();
            renderAll();
            scheduleAutoPreview();
            setStatus('success', 'Peak detection updated. ' + peaks.length + ' peaks, ' + intervals.length + ' intervals.');
        }
    });
}

function showModal(title, fields, onApply) {
    var ov = document.createElement('div');
    ov.className = 'modal-overlay';
    var md = document.createElement('div');
    md.className = 'modal';
    var html = '<div class="modal-title">' + title + '</div>';
    for (var i = 0; i < fields.length; i++) {
        var f = fields[i];
        html += '<div class="form-group"><label class="form-label">' + f.label + '</label>' +
            '<input class="form-input" type="' + f.type + '" id="' + f.id + '" value="' + f.value + '"' +
            (f.min !== undefined ? ' min="'+f.min+'"' : '') +
            (f.max !== undefined ? ' max="'+f.max+'"' : '') +
            (f.step !== undefined ? ' step="'+f.step+'"' : '') +
            '></div>';
    }
    html += '<div class="modal-btns">' +
        '<button class="btn-secondary btn-sm" id="modal-cancel">Cancel</button>' +
        '<button class="btn-primary btn-sm" id="modal-apply">Apply</button></div>';
    md.innerHTML = html;
    ov.appendChild(md);
    document.body.appendChild(ov);
    document.getElementById('modal-cancel').onclick = function() { document.body.removeChild(ov); };
    document.getElementById('modal-apply').onclick = function() { onApply(); document.body.removeChild(ov); };
    ov.onclick = function(e) { if (e.target === ov) document.body.removeChild(ov); };
}

/* Variable Selection Modal (Load Data) */
function showVariableSelectionModal(payload) {
    var vars = payload.variables || [];
    var vectors = payload.vectors || [];
    var isEmpty = (vars.length === 0);

    var ov = document.createElement('div');
    ov.className = 'modal-overlay';

    var md = document.createElement('div');
    md.className = 'modal';
    md.style.minWidth = '400px';
    md.style.maxWidth = '500px';
    md.style.maxHeight = '70vh';
    md.style.display = 'flex';
    md.style.flexDirection = 'column';

    var html = '<div class="modal-title">Load Data from Workspace</div>';

    if (isEmpty) {
        html += '<div style="padding:40px 20px;text-align:center;color:var(--text-secondary);">';
        html += '<div style="font-size:48px;margin-bottom:16px;">&#128237;</div>';
        html += '<div style="font-size:16px;font-weight:500;margin-bottom:8px;">No numeric matrices found</div>';
        html += '<div style="font-size:14px;">Load spectral data into the MATLAB workspace first.</div>';
        html += '</div>';
        html += '<div class="modal-btns">';
        html += '<button class="btn-secondary btn-sm" id="var-modal-cancel">Close</button>';
        html += '</div>';
    } else {
        html += '<div style="margin-bottom:12px;color:var(--text-secondary);font-size:14px;">Select a spectral data matrix:</div>';
        html += '<div style="flex:1;overflow-y:auto;border:1px solid var(--border-color);border-radius:8px;margin-bottom:12px;">';
        html += '<table class="intervals-table" style="width:100%"><thead><tr>';
        html += '<th style="width:40px;"></th><th>Variable</th><th>Size</th><th>Samples</th><th>Channels</th>';
        html += '</tr></thead><tbody id="var-list-tbody">';

        for (var i = 0; i < vars.length; i++) {
            var v = vars[i];
            html += '<tr class="var-row" data-varname="' + v.name + '" data-cols="' + v.cols + '" style="cursor:pointer;">';
            html += '<td style="text-align:center;"><input type="radio" name="var-select" value="' + v.name + '"' + (i === 0 ? ' checked' : '') + '></td>';
            html += '<td style="font-weight:600;">' + v.name + '</td>';
            html += '<td>' + v.size + '</td>';
            html += '<td>' + v.rows + '</td>';
            html += '<td>' + v.cols + '</td>';
            html += '</tr>';
        }

        html += '</tbody></table></div>';

        // X-axis vector selector
        html += '<div style="margin-bottom:16px;display:flex;align-items:center;gap:8px;">';
        html += '<label style="font-size:13px;color:var(--text-secondary);white-space:nowrap;">X-axis (optional):</label>';
        html += '<select id="xaxis-select" style="flex:1;padding:5px 8px;border:1px solid var(--border-color);border-radius:6px;background:var(--bg-primary);color:var(--text-primary);font-size:13px;">';
        html += '<option value="">Column indices (1, 2, 3, ...)</option>';
        for (var i = 0; i < vectors.length; i++) {
            html += '<option value="' + vectors[i].name + '">' + vectors[i].name + ' (' + vectors[i].length + ')</option>';
        }
        html += '</select>';
        html += '</div>';

        html += '<div class="modal-btns">';
        html += '<button class="btn-secondary btn-sm" id="var-modal-cancel">Cancel</button>';
        html += '<button class="btn-primary btn-sm" id="var-modal-load">Load</button>';
        html += '</div>';
    }

    md.innerHTML = html;
    ov.appendChild(md);
    document.body.appendChild(ov);

    // Helper to get selected x-axis variable
    function getSelectedXAxis() {
        var sel = document.getElementById('xaxis-select');
        return sel ? sel.value : '';
    }

    // Row click selects the radio button (only if not empty)
    if (!isEmpty) {
        var rows = md.querySelectorAll('.var-row');
        for (var j = 0; j < rows.length; j++) {
            rows[j].onclick = function() {
                var radio = this.querySelector('input[type="radio"]');
                radio.checked = true;
                // Highlight selected row
                var allRows = md.querySelectorAll('.var-row');
                for (var k = 0; k < allRows.length; k++) allRows[k].classList.remove('selected');
                this.classList.add('selected');
            };
            // Double-click to load immediately
            rows[j].ondblclick = function() {
                var varName = this.dataset.varname;
                var xAxis = getSelectedXAxis();
                document.body.removeChild(ov);
                var params = { varName: varName };
                if (xAxis) params.xAxisVar = xAxis;
                sendAction('loadVariable', params);
            };
        }

        // Select first row by default
        if (rows.length > 0) rows[0].classList.add('selected');

        document.getElementById('var-modal-load').onclick = function() {
            var selected = md.querySelector('input[name="var-select"]:checked');
            if (selected) {
                var varName = selected.value;
                var xAxis = getSelectedXAxis();
                document.body.removeChild(ov);
                var params = { varName: varName };
                if (xAxis) params.xAxisVar = xAxis;
                sendAction('loadVariable', params);
            }
        };
    }

    document.getElementById('var-modal-cancel').onclick = function() {
        document.body.removeChild(ov);
        setStatus('idle', isEmpty ? '' : 'Load cancelled');
    };

    ov.onclick = function(e) {
        if (e.target === ov) {
            document.body.removeChild(ov);
            setStatus('idle', isEmpty ? '' : 'Load cancelled');
        }
    };

    // Handle Escape key
    var escHandler = function(e) {
        if (e.key === 'Escape') {
            document.body.removeChild(ov);
            setStatus('idle', 'Load cancelled');
            document.removeEventListener('keydown', escHandler);
        }
    };
    document.addEventListener('keydown', escHandler);
}

/* Table Selection Modal (Load Intervals) */
function showTableSelectionModal(payload) {
    var tables = payload.tables || [];
    if (tables.length === 0) {
        setStatus('error', 'No tables in workspace');
        return;
    }

    var ov = document.createElement('div');
    ov.className = 'modal-overlay';

    var md = document.createElement('div');
    md.className = 'modal';
    md.style.minWidth = '350px';
    md.style.maxWidth = '450px';
    md.style.maxHeight = '60vh';
    md.style.display = 'flex';
    md.style.flexDirection = 'column';

    var html = '<div class="modal-title">Load Intervals</div>';
    html += '<div style="margin-bottom:12px;color:var(--text-secondary);font-size:14px;">Select an interval table:</div>';
    html += '<div style="flex:1;overflow-y:auto;border:1px solid var(--border-color);border-radius:8px;margin-bottom:16px;">';
    html += '<table class="intervals-table" style="width:100%"><thead><tr>';
    html += '<th style="width:40px;"></th><th>Table</th><th>Rows</th>';
    html += '</tr></thead><tbody>';

    for (var i = 0; i < tables.length; i++) {
        var t = tables[i];
        html += '<tr class="table-row" data-tablename="' + t.name + '" style="cursor:pointer;">';
        html += '<td style="text-align:center;"><input type="radio" name="table-select" value="' + t.name + '"' + (i === 0 ? ' checked' : '') + '></td>';
        html += '<td style="font-weight:600;">' + t.name + '</td>';
        html += '<td>' + t.rows + '</td>';
        html += '</tr>';
    }

    html += '</tbody></table></div>';
    html += '<div class="modal-btns">';
    html += '<button class="btn-secondary btn-sm" id="table-modal-cancel">Cancel</button>';
    html += '<button class="btn-primary btn-sm" id="table-modal-load">Load</button>';
    html += '</div>';

    md.innerHTML = html;
    ov.appendChild(md);
    document.body.appendChild(ov);

    var rows = md.querySelectorAll('.table-row');
    for (var j = 0; j < rows.length; j++) {
        rows[j].onclick = function() {
            var radio = this.querySelector('input[type="radio"]');
            radio.checked = true;
            var allRows = md.querySelectorAll('.table-row');
            for (var k = 0; k < allRows.length; k++) allRows[k].classList.remove('selected');
            this.classList.add('selected');
        };
        rows[j].ondblclick = function() {
            var tableName = this.dataset.tablename;
            document.body.removeChild(ov);
            sendAction('loadIntervalTable', { tableName: tableName });
        };
    }
    if (rows.length > 0) rows[0].classList.add('selected');

    document.getElementById('table-modal-cancel').onclick = function() {
        document.body.removeChild(ov);
        setStatus('idle', 'Cancelled');
    };

    document.getElementById('table-modal-load').onclick = function() {
        var selected = md.querySelector('input[name="table-select"]:checked');
        if (selected) {
            document.body.removeChild(ov);
            sendAction('loadIntervalTable', { tableName: selected.value });
        }
    };

    ov.onclick = function(e) {
        if (e.target === ov) {
            document.body.removeChild(ov);
            setStatus('idle', 'Cancelled');
        }
    };

    var escHandler = function(e) {
        if (e.key === 'Escape') {
            document.body.removeChild(ov);
            setStatus('idle', 'Cancelled');
            document.removeEventListener('keydown', escHandler);
        }
    };
    document.addEventListener('keydown', escHandler);
}

function showHelp() {
    var ov = document.createElement('div');
    ov.className = 'modal-overlay';
    var md = document.createElement('div');
    md.className = 'modal';
    md.style.maxWidth = '520px';
    md.innerHTML = '<div class="modal-title">LASLS Baseline Correction Help</div>' +
        '<div style="font-size:16px;color:var(--text-secondary);line-height:1.6;">' +
        '<b>Workflow:</b><br>' +
        '1. Load data matrix from workspace<br>' +
        '2. Adjust global <i>&lambda;</i>, <i>p</i>, <i>&mu;</i> using sliders<br>' +
        '3. Draw intervals on peaks (click Draw, then drag on preview)<br>' +
        '4. Tune per-interval <i>&lambda;</i><sub>in</sub> and <i>p</i><sub>in</sub> in Interval tab<br>' +
        '5. Use Apply to correct all spectra<br><br>' +
        '<b>Features:</b><br>' +
        '&bull; Signal-by-signal navigation via burger menu<br>' +
        '&bull; Per-signal parameters mode (each signal has own intervals)<br>' +
        '&bull; Show all data overlays all spectra<br>' +
        '&bull; Peak detection and navigation<br>' +
        '&bull; Drag interval edges on chart to resize<br>' +
        '&bull; Gear buttons configure slider ranges<br>' +
        '&bull; Arrow buttons fine-tune parameters<br>' +
        '&bull; Export/Load interval tables for reproducibility<br>' +
        '&bull; Scroll to zoom, drag to pan, double-click to reset view<br>' +
        '&bull; Ctrl+D to toggle dark mode<br>' +
        '</div>' +
        '<div class="modal-btns"><button class="btn-primary btn-sm" id="help-close-btn">Close</button></div>';
    ov.appendChild(md);
    document.body.appendChild(ov);
    document.getElementById('help-close-btn').onclick = function() { ov.remove(); };
    ov.onclick = function(e) { if (e.target === ov) ov.remove(); };
}

function resetAllViews() {
    previewView = null; correctedView = null;
    renderAll();
}

/* ====================================================================
   CANVAS 2D DRAWING UTILITIES
   ==================================================================== */
function getColors() {
    var cs = getComputedStyle(document.documentElement);
    return {
        spectrum: cs.getPropertyValue('--spectrum-color').trim(),
        meanSpectrum: cs.getPropertyValue('--mean-spectrum-color').trim(),
        baseline: cs.getPropertyValue('--baseline-color').trim(),
        corrected: cs.getPropertyValue('--corrected-color').trim(),
        intFill: cs.getPropertyValue('--interval-fill').trim(),
        intBorder: cs.getPropertyValue('--interval-border').trim(),
        intSelFill: cs.getPropertyValue('--interval-selected-fill').trim(),
        intSelBorder: cs.getPropertyValue('--interval-selected-border').trim(),
        allSpectra: cs.getPropertyValue('--all-spectra-color').trim(),
        peak: cs.getPropertyValue('--peak-color').trim(),
        grid: cs.getPropertyValue('--grid-color').trim(),
        text: cs.getPropertyValue('--axis-text').trim()
    };
}

function updateLegendSwatches() {
    var c = getColors();
    var s = document.getElementById('swatch-spectrum');
    if (s) s.style.background = signalMode ? c.spectrum : c.meanSpectrum;
    s = document.getElementById('swatch-baseline'); if (s) s.style.background = c.baseline;
    s = document.getElementById('swatch-interval'); if (s) s.style.background = c.intBorder;
    s = document.getElementById('swatch-corrected');
    if (s) s.style.background = signalMode ? c.corrected : c.meanSpectrum;
    // Update legend text
    var specLabel = document.getElementById('legend-spectrum-label');
    if (specLabel) specLabel.textContent = signalMode ? 'Signal ' + currentSignal : (nSamples > 1 ? 'Mean' : 'Spectrum');
    var corrLabel = document.getElementById('legend-corrected-label');
    if (corrLabel) corrLabel.textContent = signalMode ? 'Corrected' : (nSamples > 1 ? 'Corrected mean' : 'Corrected');
}

var MARGIN = { top: 10, right: 16, bottom: 48, left: 72 };
var axisLabels = {
    previewX: 'Channel', previewY: 'Intensity',
    correctedX: 'Channel', correctedY: 'Intensity'
};

function setupCanvas(canvasId) {
    var canvas = document.getElementById(canvasId);
    var rect = canvas.parentElement.getBoundingClientRect();
    if (rect.width === 0 || rect.height === 0) return null;
    var dpr = window.devicePixelRatio || 1;
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    canvas.style.width = rect.width + 'px';
    canvas.style.height = rect.height + 'px';
    var ctx = canvas.getContext('2d');
    ctx.scale(dpr, dpr);
    return { ctx: ctx, w: rect.width, h: rect.height };
}

function getDataRange(arrays) {
    var mn = Infinity, mx = -Infinity;
    for (var a = 0; a < arrays.length; a++)
        for (var i = 0; i < arrays[a].length; i++) {
            if (arrays[a][i] < mn) mn = arrays[a][i];
            if (arrays[a][i] > mx) mx = arrays[a][i];
        }
    if (mn === mx) { mn -= 1; mx += 1; }
    var pad = (mx - mn) * 0.05;
    return { min: mn - pad, max: mx + pad };
}

function drawGrid(ctx, w, h, xMin, xMax, yMin, yMax, colors, xLabel, yLabel) {
    var m = MARGIN, pw = w - m.left - m.right, ph = h - m.top - m.bottom;
    ctx.strokeStyle = colors.grid; ctx.lineWidth = 1;
    for (var i = 0; i <= 6; i++) {
        var xPx = m.left + pw * i / 6;
        ctx.beginPath(); ctx.moveTo(xPx, m.top); ctx.lineTo(xPx, m.top + ph); ctx.stroke();
    }
    for (var j = 0; j <= 4; j++) {
        var yPx = m.top + ph - ph * j / 4;
        ctx.beginPath(); ctx.moveTo(m.left, yPx); ctx.lineTo(m.left + pw, yPx); ctx.stroke();
    }
    ctx.strokeStyle = colors.text; ctx.lineWidth = 1; ctx.globalAlpha = 0.3;
    ctx.beginPath();
    ctx.moveTo(m.left, m.top + ph); ctx.lineTo(m.left + pw, m.top + ph);
    ctx.moveTo(m.left, m.top); ctx.lineTo(m.left, m.top + ph);
    ctx.stroke(); ctx.globalAlpha = 1.0;

    ctx.fillStyle = colors.text;
    ctx.font = '13px -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, sans-serif';
    ctx.textAlign = 'center'; ctx.textBaseline = 'top';
    for (var i = 0; i <= 6; i++) {
        ctx.fillText((xMin + (xMax - xMin) * i / 6).toFixed(0), m.left + pw * i / 6, m.top + ph + 5);
    }
    ctx.textAlign = 'right'; ctx.textBaseline = 'middle';
    for (var j = 0; j <= 4; j++) {
        var yVal = yMin + (yMax - yMin) * j / 4;
        var lbl = (Math.abs(yVal) < 1000 && Math.abs(yVal) > 0.01) ? yVal.toFixed(2) : yVal.toExponential(1);
        ctx.fillText(lbl, m.left - 5, m.top + ph - ph * j / 4);
    }
    // X-axis label
    if (xLabel) {
        ctx.fillStyle = colors.text; ctx.globalAlpha = 0.6;
        ctx.font = '12px -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, sans-serif';
        ctx.textAlign = 'center'; ctx.textBaseline = 'top';
        ctx.fillText(xLabel, m.left + pw / 2, m.top + ph + 22);
        ctx.globalAlpha = 1.0;
    }
    // Y-axis label (rotated)
    if (yLabel) {
        ctx.save();
        ctx.fillStyle = colors.text; ctx.globalAlpha = 0.6;
        ctx.font = '12px -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, sans-serif';
        ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
        ctx.translate(12, m.top + ph / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.fillText(yLabel, 0, 0);
        ctx.restore();
        ctx.globalAlpha = 1.0;
    }
    return { plotW: pw, plotH: ph };
}

function drawLine(ctx, xData, yData, xMin, xMax, yMin, yMax, pw, ph, color, lw, dash) {
    var m = MARGIN, xR = (xMax - xMin) || 1, yR = (yMax - yMin) || 1;
    ctx.strokeStyle = color; ctx.lineWidth = lw || 1.5;
    if (dash) ctx.setLineDash(dash); else ctx.setLineDash([]);

    // Find visible range indices
    var iStart = 0, iEnd = xData.length - 1;
    while (iStart < xData.length && xData[iStart] < xMin) iStart++;
    while (iEnd >= 0 && xData[iEnd] > xMax) iEnd--;
    if (iStart > 0) iStart--;  // include one point before view for continuity
    if (iEnd < xData.length - 1) iEnd++;
    var visibleCount = iEnd - iStart + 1;

    // Min/max per-pixel-bucket downsampling when data >> pixels
    var maxPoints = pw * 2;  // 2 points per pixel preserves all visual detail
    ctx.beginPath();
    if (visibleCount > maxPoints && visibleCount > 4) {
        var bucketSize = visibleCount / (maxPoints / 2);  // each bucket produces 2 points (min+max)
        var started = false;
        for (var b = 0; b < maxPoints / 2; b++) {
            var bStart = iStart + Math.floor(b * bucketSize);
            var bEnd = Math.min(iStart + Math.floor((b + 1) * bucketSize), iEnd + 1);
            var minY = Infinity, maxY = -Infinity, minI = bStart, maxI = bStart;
            for (var j = bStart; j < bEnd; j++) {
                if (yData[j] < minY) { minY = yData[j]; minI = j; }
                if (yData[j] > maxY) { maxY = yData[j]; maxI = j; }
            }
            // Draw min then max in data order to preserve shape
            var pts = minI < maxI ? [minI, maxI] : [maxI, minI];
            for (var k = 0; k < 2; k++) {
                var x = m.left + (xData[pts[k]] - xMin) / xR * pw;
                var y = m.top + ph - (yData[pts[k]] - yMin) / yR * ph;
                if (!started) { ctx.moveTo(x, y); started = true; } else ctx.lineTo(x, y);
            }
        }
    } else {
        var started = false;
        for (var i = iStart; i <= iEnd; i++) {
            var x = m.left + (xData[i] - xMin) / xR * pw;
            var y = m.top + ph - (yData[i] - yMin) / yR * ph;
            if (!started) { ctx.moveTo(x, y); started = true; } else ctx.lineTo(x, y);
        }
    }
    ctx.stroke(); ctx.setLineDash([]);
}

function drawIntervalShading(ctx, ints, wl, xMin, xMax, yMin, yMax, pw, ph, colors) {
    if (!ints || ints.length === 0) return;
    var m = MARGIN, xR = (xMax - xMin) || 1;
    for (var i = 0; i < ints.length; i++) {
        var intv = ints[i];
        var s = idxToXVal(intv.startIdx), e = idxToXVal(intv.endIdx);
        if (e < xMin || s > xMax) continue;
        s = Math.max(s, xMin); e = Math.min(e, xMax);
        var x1 = m.left + (s - xMin) / xR * pw;
        var x2 = m.left + (e - xMin) / xR * pw;
        var isSel = (i === selectedIdx);
        ctx.fillStyle = isSel ? colors.intSelFill : colors.intFill;
        ctx.fillRect(x1, m.top, x2 - x1, ph);
        ctx.strokeStyle = isSel ? colors.intSelBorder : colors.intBorder;
        ctx.lineWidth = isSel ? 2 : 1;
        ctx.strokeRect(x1, m.top, x2 - x1, ph);
        ctx.fillStyle = isSel ? colors.intSelBorder : colors.intBorder;
        ctx.font = '13px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'top';
        ctx.fillText('I' + (i+1), (x1 + x2) / 2, m.top + 4);
    }
}

function drawPeakMarkers(ctx, peaks, xMin, xMax, yMin, yMax, pw, ph, colors) {
    if (!peaksEnabled || peaks.length === 0) return;
    var m = MARGIN, xR = (xMax - xMin) || 1, yR = (yMax - yMin) || 1;
    for (var i = 0; i < peaks.length; i++) {
        var px = peaks[i].x;
        if (px < xMin || px > xMax) continue;
        var x = m.left + (px - xMin) / xR * pw;

        // Get animation state for this peak
        var appear = (peakGlowState[i] && peakGlowState[i].appear !== undefined) ? peakGlowState[i].appear : 1;
        var glow = (peakGlowState[i] && peakGlowState[i].glow !== undefined) ? peakGlowState[i].glow : 0;

        if (appear <= 0) continue; // Not visible yet

        // Draw glow effect if active
        if (glow > 0) {
            var glowWidth = 12 + glow * 8;
            var gradient = ctx.createLinearGradient(x - glowWidth, 0, x + glowWidth, 0);
            gradient.addColorStop(0, 'rgba(255, 193, 7, 0)');
            gradient.addColorStop(0.3, 'rgba(255, 193, 7, ' + (glow * 0.3) + ')');
            gradient.addColorStop(0.5, 'rgba(255, 193, 7, ' + (glow * 0.6) + ')');
            gradient.addColorStop(0.7, 'rgba(255, 193, 7, ' + (glow * 0.3) + ')');
            gradient.addColorStop(1, 'rgba(255, 193, 7, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(x - glowWidth, m.top, glowWidth * 2, ph);
        }

        // Draw peak line with fade-in
        ctx.globalAlpha = appear;
        ctx.strokeStyle = colors.peak; ctx.lineWidth = 1; ctx.setLineDash([3,3]);
        ctx.beginPath(); ctx.moveTo(x, m.top); ctx.lineTo(x, m.top + ph); ctx.stroke();
        ctx.setLineDash([]);

        // Draw marker dot for current peak
        if (i === currentPeak) {
            ctx.fillStyle = colors.peak;
            ctx.beginPath(); ctx.arc(x, m.top + 6, 4, 0, Math.PI * 2); ctx.fill();
        }
        ctx.globalAlpha = 1;
    }
}

function drawDrawingRect(ctx, xMin, xMax, yMin, yMax, pw, ph) {
    if (!drawingMode || !drawStart || !drawCurrent) return;
    var m = MARGIN, xR = (xMax - xMin) || 1;
    var x1 = m.left + (drawStart - xMin) / xR * pw;
    var x2 = m.left + (drawCurrent - xMin) / xR * pw;
    ctx.fillStyle = 'rgba(66, 165, 245, 0.15)';
    ctx.fillRect(Math.min(x1,x2), m.top, Math.abs(x2-x1), ph);
    ctx.strokeStyle = 'rgba(66, 165, 245, 0.6)'; ctx.lineWidth = 2;
    ctx.strokeRect(Math.min(x1,x2), m.top, Math.abs(x2-x1), ph);
}

/* ====================================================================
   RENDER CHARTS
   ==================================================================== */
function getAutoView(chartType) {
    if (chartType === 'preview') {
        var allY = [currentSpectrum];
        if (baselineData.length > 0) allY.push(baselineData);
        var yr = getDataRange(allY);
        return { xMin: wavelength[0], xMax: wavelength[wavelength.length-1], yMin: yr.min, yMax: yr.max };
    } else {
        var d = correctedPreview.length > 0 ? correctedPreview : [0,1];
        var yr = getDataRange([d]);
        return { xMin: wavelength[0], xMax: wavelength[wavelength.length-1], yMin: yr.min, yMax: yr.max };
    }
}

function renderPreviewChart() {
    var canvas = document.getElementById('preview-canvas');
    var emptyEl = document.getElementById('preview-empty');
    if (currentSpectrum.length === 0) {
        canvas.style.display = 'none'; emptyEl.style.display = 'flex';
        document.getElementById('preview-legend').style.display = 'none';
        return;
    }
    emptyEl.style.display = 'none'; canvas.style.display = 'block';
    document.getElementById('preview-legend').style.display = 'flex';

    var c = setupCanvas('preview-canvas');
    if (!c) return;
    var colors = getColors();
    c.ctx.clearRect(0, 0, c.w, c.h);

    var allY = [currentSpectrum];
    if (baselineData.length > 0) allY.push(baselineData);
    var autoY = getDataRange(allY);
    var autoX = { min: wavelength[0], max: wavelength[wavelength.length-1] };
    var view = previewView || { xMin: autoX.min, xMax: autoX.max, yMin: autoY.min, yMax: autoY.max };
    var layout = drawGrid(c.ctx, c.w, c.h, view.xMin, view.xMax, view.yMin, view.yMax, colors, axisLabels.previewX, axisLabels.previewY);

    drawIntervalShading(c.ctx, intervals, wavelength, view.xMin, view.xMax, view.yMin, view.yMax, layout.plotW, layout.plotH, colors);

    if (showAllSpectra && !signalMode && allSpectra.length > 1) {
        for (var i = 0; i < allSpectra.length; i++) {
            drawLine(c.ctx, wavelength, allSpectra[i], view.xMin, view.xMax, view.yMin, view.yMax, layout.plotW, layout.plotH, colors.allSpectra, 0.5);
        }
    }

    // Use dark gray for mean spectrum, blue only in signal-by-signal mode
    var spectrumColor = signalMode ? colors.spectrum : colors.meanSpectrum;
    drawLine(c.ctx, wavelength, currentSpectrum, view.xMin, view.xMax, view.yMin, view.yMax, layout.plotW, layout.plotH, spectrumColor, 1.5);

    if (baselineData.length > 0) {
        drawLine(c.ctx, wavelength, baselineData, view.xMin, view.xMax, view.yMin, view.yMax, layout.plotW, layout.plotH, colors.baseline, 2, [6,3]);
    }

    drawPeakMarkers(c.ctx, peaks, view.xMin, view.xMax, view.yMin, view.yMax, layout.plotW, layout.plotH, colors);
    drawDrawingRect(c.ctx, view.xMin, view.xMax, view.yMin, view.yMax, layout.plotW, layout.plotH);
}

function renderCorrectedChart() {
    var canvas = document.getElementById('corrected-canvas');
    var emptyEl = document.getElementById('corrected-empty');
    if (correctedPreview.length === 0) {
        canvas.style.display = 'none'; emptyEl.style.display = 'flex';
        document.getElementById('corrected-legend').style.display = 'none';
        return;
    }
    emptyEl.style.display = 'none'; canvas.style.display = 'block';
    document.getElementById('corrected-legend').style.display = 'flex';

    var c = setupCanvas('corrected-canvas');
    if (!c) return;
    var colors = getColors();
    c.ctx.clearRect(0, 0, c.w, c.h);

    var autoY = getDataRange([correctedPreview]);
    var autoX = { min: wavelength[0], max: wavelength[wavelength.length-1] };
    var view = correctedView || { xMin: autoX.min, xMax: autoX.max, yMin: autoY.min, yMax: autoY.max };
    var layout = drawGrid(c.ctx, c.w, c.h, view.xMin, view.xMax, view.yMin, view.yMax, colors, axisLabels.correctedX, axisLabels.correctedY);

    // Draw horizontal zero reference line (pale red, dashed)
    if (view.yMin < 0 && view.yMax > 0) {
        var m = MARGIN;
        var yZero = m.top + layout.plotH - (0 - view.yMin) / (view.yMax - view.yMin) * layout.plotH;
        c.ctx.save();
        c.ctx.strokeStyle = 'rgba(239, 83, 80, 0.5)';
        c.ctx.lineWidth = 1;
        c.ctx.setLineDash([6, 4]);
        c.ctx.beginPath();
        c.ctx.moveTo(m.left, yZero);
        c.ctx.lineTo(m.left + layout.plotW, yZero);
        c.ctx.stroke();
        c.ctx.restore();
    }

    if (showAllSpectra && !signalMode && allCorrectedData.length > 1) {
        for (var i = 0; i < allCorrectedData.length; i++) {
            drawLine(c.ctx, wavelength, allCorrectedData[i], view.xMin, view.xMax, view.yMin, view.yMax, layout.plotW, layout.plotH, colors.allSpectra, 0.5);
        }
    }

    // Use dark gray for mean corrected, green only in signal mode
    var corrColor = signalMode ? colors.corrected : colors.meanSpectrum;
    drawLine(c.ctx, wavelength, correctedPreview, view.xMin, view.xMax, view.yMin, view.yMax, layout.plotW, layout.plotH, corrColor, 1.5);
}

function renderAll() { renderPreviewChart(); renderCorrectedChart(); }

/* ====================================================================
   ZOOM / PAN
   ==================================================================== */
function handleWheel(e, chartType) {
    e.preventDefault();
    var data = (chartType === 'preview') ? currentSpectrum : correctedPreview;
    if (data.length === 0) return;
    var view = (chartType === 'preview') ? previewView : correctedView;
    if (!view) view = getAutoView(chartType);
    var factor = e.deltaY > 0 ? 1.15 : 0.87;
    var canvas = document.getElementById(chartType === 'preview' ? 'preview-canvas' : 'corrected-canvas');
    var rect = canvas.getBoundingClientRect();
    var pw = rect.width - MARGIN.left - MARGIN.right;
    var ph = rect.height - MARGIN.top - MARGIN.bottom;
    var fracX = Math.max(0, Math.min(1, (e.clientX - rect.left - MARGIN.left) / pw));
    var fracY = Math.max(0, Math.min(1, 1 - (e.clientY - rect.top - MARGIN.top) / ph));
    var xAt = view.xMin + (view.xMax - view.xMin) * fracX;
    var yAt = view.yMin + (view.yMax - view.yMin) * fracY;
    var nxr = (view.xMax - view.xMin) * factor;
    var nyr = (view.yMax - view.yMin) * factor;
    var nv = { xMin: xAt - nxr * fracX, xMax: xAt + nxr * (1-fracX), yMin: yAt - nyr * fracY, yMax: yAt + nyr * (1-fracY) };
    if (chartType === 'preview') { previewView = nv; renderPreviewChart(); }
    else { correctedView = nv; renderCorrectedChart(); }
}

function handleMouseDown(e, chartType) {
    // Middle mouse button (wheel click) = pan, even in drawing mode
    if (e.button === 1) {
        e.preventDefault();
        var view = (chartType === 'preview') ? previewView : correctedView;
        if (!view) view = getAutoView(chartType);
        panState = { chart: chartType, startX: e.clientX, startY: e.clientY, origView: JSON.parse(JSON.stringify(view)), middleButton: true };
        return;
    }

    // Check for interval edge resize (on preview, left button) - works in draw mode too
    if (chartType === 'preview' && e.button === 0) {
        var edgeInfo = getIntervalEdgeAtMouse(e);
        if (edgeInfo) {
            resizeState = {
                intervalIdx: edgeInfo.idx,
                edge: edgeInfo.edge,
                startX: e.clientX,
                origStart: intervals[edgeInfo.idx].startIdx,
                origEnd: intervals[edgeInfo.idx].endIdx
            };
            selectInterval(edgeInfo.idx);
            return;
        }
    }

    // Left click in drawing mode = draw interval (only if not near edge)
    if (drawingMode && chartType === 'preview' && e.button === 0) {
        var canvas = document.getElementById('preview-canvas');
        drawStart = canvasXToData(canvas, e.clientX);
        drawCurrent = drawStart;
        return;
    }

    // Left click normally = pan
    if (e.button === 0) {
        var view = (chartType === 'preview') ? previewView : correctedView;
        if (!view) view = getAutoView(chartType);
        panState = { chart: chartType, startX: e.clientX, startY: e.clientY, origView: JSON.parse(JSON.stringify(view)), middleButton: false };
    }
}

function handleMouseMove(e) {
    // Handle interval resizing (highest priority)
    if (resizeState) {
        var canvas = document.getElementById('preview-canvas');
        var newX = canvasXToData(canvas, e.clientX);
        var idx = resizeState.intervalIdx;

        if (resizeState.edge === 'left') {
            var newStart = Math.max(1, Math.min(intervals[idx].endIdx - 3, xValToIdx(newX)));
            // Prevent overlap: find nearest left neighbor
            for (var oi = 0; oi < intervals.length; oi++) {
                if (oi === idx) continue;
                if (intervals[oi].endIdx < intervals[idx].endIdx && intervals[oi].endIdx >= newStart) {
                    newStart = Math.max(newStart, intervals[oi].endIdx + 1);
                }
            }
            intervals[idx].startIdx = newStart;
        } else {
            var newEnd = Math.min(wavelength.length, Math.max(intervals[idx].startIdx + 3, xValToIdx(newX)));
            // Prevent overlap: find nearest right neighbor
            for (var oi = 0; oi < intervals.length; oi++) {
                if (oi === idx) continue;
                if (intervals[oi].startIdx > intervals[idx].startIdx && intervals[oi].startIdx <= newEnd) {
                    newEnd = Math.min(newEnd, intervals[oi].startIdx - 1);
                }
            }
            intervals[idx].endIdx = newEnd;
        }

        updateIntervalTable();
        renderPreviewChart();
        return;
    }

    // Handle panning (middle button has priority)
    if (panState) {
        var ct = panState.chart;
        var canvas = document.getElementById(ct === 'preview' ? 'preview-canvas' : 'corrected-canvas');
        var rect = canvas.getBoundingClientRect();
        var pw = rect.width - MARGIN.left - MARGIN.right;
        var ph = rect.height - MARGIN.top - MARGIN.bottom;
        var ov = panState.origView;
        var xShift = -(e.clientX - panState.startX) / pw * (ov.xMax - ov.xMin);
        var yShift = (e.clientY - panState.startY) / ph * (ov.yMax - ov.yMin);
        var nv = { xMin: ov.xMin + xShift, xMax: ov.xMax + xShift, yMin: ov.yMin + yShift, yMax: ov.yMax + yShift };
        if (ct === 'preview') { previewView = nv; renderPreviewChart(); }
        else { correctedView = nv; renderCorrectedChart(); }
        return;
    }

    // Handle drawing
    if (drawingMode && drawStart !== null) {
        var canvas = document.getElementById('preview-canvas');
        drawCurrent = canvasXToData(canvas, e.clientX);
        renderPreviewChart();
        return;
    }

    // Update cursor for interval edge hover (even in drawing mode)
    if (!panState && !resizeState) {
        updateResizeCursor(e);
    }
}

function handleMouseUp(e) {
    // End interval resize
    if (resizeState && e.button === 0) {
        resizeState = null;
        justResized = true;  // Prevent click from triggering
        scheduleAutoPreview();
        setStatus('success', 'Interval resized');
        return;
    }

    // End panning (middle button)
    if (panState && panState.middleButton && e.button === 1) {
        panState = null;
        return;
    }

    // End drawing (left button in draw mode)
    if (drawingMode && drawStart !== null && e.button === 0) {
        var canvas = document.getElementById('preview-canvas');
        var endX = canvasXToData(canvas, e.clientX);
        // Keep drawing mode active - don't exit after completing a draw
        var drawIdxSpan = Math.abs(xValToIdx(endX) - xValToIdx(drawStart));
        if (drawIdxSpan >= 2) {
            addIntervalFromDraw(drawStart, endX);
            setStatus('processing', 'Interval added. Draw another or click elsewhere to exit.');
        } else {
            setStatus('processing', 'Draw cancelled (too small). Try again or click elsewhere to exit.');
        }
        drawStart = null; drawCurrent = null;
        renderPreviewChart();
        return;
    }

    // End normal panning (left button)
    if (panState && e.button === 0) {
        panState = null;
    }
}

/* Helper: detect if mouse is near an interval edge */
function getIntervalEdgeAtMouse(e) {
    if (intervals.length === 0 || wavelength.length === 0) return null;

    var canvas = document.getElementById('preview-canvas');
    var rect = canvas.getBoundingClientRect();
    var view = previewView || getAutoView('preview');
    var pw = rect.width - MARGIN.left - MARGIN.right;
    var mx = e.clientX - rect.left;

    for (var i = 0; i < intervals.length; i++) {
        var intv = intervals[i];
        // Convert interval edges to pixel positions via x-axis values
        var leftXVal = idxToXVal(intv.startIdx);
        var rightXVal = idxToXVal(intv.endIdx);
        var leftPx = MARGIN.left + (leftXVal - view.xMin) / (view.xMax - view.xMin) * pw;
        var rightPx = MARGIN.left + (rightXVal - view.xMin) / (view.xMax - view.xMin) * pw;

        // Check if near left edge
        if (Math.abs(mx - leftPx) < EDGE_THRESHOLD) {
            return { idx: i, edge: 'left' };
        }
        // Check if near right edge
        if (Math.abs(mx - rightPx) < EDGE_THRESHOLD) {
            return { idx: i, edge: 'right' };
        }
    }
    return null;
}

/* Helper: update cursor based on edge hover */
function updateResizeCursor(e) {
    var canvas = document.getElementById('preview-canvas');
    var edgeInfo = getIntervalEdgeAtMouse(e);

    if (edgeInfo) {
        canvas.style.cursor = 'ew-resize';
    } else if (drawingMode) {
        canvas.style.cursor = 'crosshair';
    } else {
        canvas.style.cursor = '';
    }
}

function stopDrawingMode() {
    if (drawingMode) {
        drawingMode = false;
        drawStart = null;
        drawCurrent = null;
        document.getElementById('preview-wrapper').classList.remove('drawing-mode');
        setStatus('idle', 'Drawing mode exited.');
        renderPreviewChart();
    }
}

var justResized = false;  // Flag to prevent click after resize

function handlePreviewClick(e) {
    if (drawingMode) return;
    if (justResized) { justResized = false; return; }  // Skip click after resize

    // Check if clicking on an interval edge (resize cursor) - don't select
    var edgeInfo = getIntervalEdgeAtMouse(e);
    if (edgeInfo) return;

    var canvas = document.getElementById('preview-canvas');
    var xClick = canvasXToData(canvas, e.clientX);
    for (var i = 0; i < intervals.length; i++) {
        if (xClick >= idxToXVal(intervals[i].startIdx) && xClick <= idxToXVal(intervals[i].endIdx)) {
            selectInterval(i);
            return;
        }
    }
}

function handleDblClick(e, chartType) {
    var canvas = document.getElementById(chartType === 'preview' ? 'preview-canvas' : 'corrected-canvas');
    var rect = canvas.getBoundingClientRect();
    var x = e.clientX - rect.left, y = e.clientY - rect.top;
    var m = MARGIN, pw = rect.width - m.left - m.right, ph = rect.height - m.top - m.bottom;
    // Check X-axis label area (bottom center)
    var xLabelCx = m.left + pw / 2, xLabelCy = m.top + ph + 30;
    if (Math.abs(x - xLabelCx) < 60 && Math.abs(y - xLabelCy) < 14) {
        editAxisLabel(canvas, chartType, 'x', xLabelCx, xLabelCy);
        return;
    }
    // Check Y-axis label area (left center, rotated)
    if (x < m.left - 5 && y > m.top && y < m.top + ph) {
        var yLabelCy = m.top + ph / 2;
        editAxisLabel(canvas, chartType, 'y', 30, yLabelCy);
        return;
    }
    resetZoom(chartType);
}

function editAxisLabel(canvas, chartType, axis, cx, cy) {
    var key = (chartType === 'preview' ? 'preview' : 'corrected') + (axis === 'x' ? 'X' : 'Y');
    var wrapper = canvas.parentElement;
    var inp = document.createElement('input');
    inp.type = 'text';
    inp.value = axisLabels[key];
    inp.style.cssText = 'position:absolute;font-size:12px;text-align:center;border:1px solid var(--accent);border-radius:4px;background:var(--bg-primary);color:var(--text-primary);padding:2px 6px;outline:none;z-index:100;width:100px;';
    inp.style.left = (cx - 50) + 'px';
    inp.style.top = (cy - 10) + 'px';
    wrapper.style.position = 'relative';
    wrapper.appendChild(inp);
    inp.focus();
    inp.select();
    function commit() {
        axisLabels[key] = inp.value;
        if (wrapper.contains(inp)) wrapper.removeChild(inp);
        renderAll();
    }
    inp.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') { commit(); }
        else if (e.key === 'Escape') { if (wrapper.contains(inp)) wrapper.removeChild(inp); }
    });
    inp.addEventListener('blur', commit);
}

function resetZoom(chartType) {
    if (chartType === 'preview') { previewView = null; renderPreviewChart(); }
    else { correctedView = null; renderCorrectedChart(); }
}

document.addEventListener('DOMContentLoaded', function() {
    var pc = document.getElementById('preview-canvas');
    var cc = document.getElementById('corrected-canvas');
    pc.addEventListener('wheel', function(e) { handleWheel(e, 'preview'); }, { passive: false });
    cc.addEventListener('wheel', function(e) { handleWheel(e, 'corrected'); }, { passive: false });
    pc.addEventListener('mousedown', function(e) { handleMouseDown(e, 'preview'); });
    cc.addEventListener('mousedown', function(e) { handleMouseDown(e, 'corrected'); });
    pc.addEventListener('click', handlePreviewClick);
    pc.addEventListener('dblclick', function(e) { handleDblClick(e, 'preview'); });
    cc.addEventListener('dblclick', function(e) { handleDblClick(e, 'corrected'); });
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);

    // Prevent middle-click auto-scroll on canvases
    pc.addEventListener('auxclick', function(e) { if (e.button === 1) e.preventDefault(); });
    cc.addEventListener('auxclick', function(e) { if (e.button === 1) e.preventDefault(); });
    pc.addEventListener('mousedown', function(e) { if (e.button === 1) e.preventDefault(); });
    cc.addEventListener('mousedown', function(e) { if (e.button === 1) e.preventDefault(); });

    // Reset cursor when leaving preview canvas
    pc.addEventListener('mouseleave', function() { pc.style.cursor = ''; });

    // Keyboard shortcuts
    document.addEventListener('keydown', function(e) {
        // Escape: exit drawing mode
        if (e.key === 'Escape' && drawingMode) {
            stopDrawingMode();
        }

        // Delete or Backspace: delete selected interval
        if ((e.key === 'Delete' || e.key === 'Backspace') && selectedIdx >= 0) {
            // Don't delete if focus is on an input field
            if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') {
                return;
            }
            e.preventDefault();
            deleteSelectedIntervals();
        }
    });

    // Exit drawing mode when clicking outside preview canvas (on buttons, panels, etc.)
    document.addEventListener('mousedown', function(e) {
        if (drawingMode) {
            var previewWrapper = document.getElementById('preview-wrapper');
            if (!previewWrapper.contains(e.target)) {
                stopDrawingMode();
            }
        }
    });
});

/* ====================================================================
   MATLAB RESPONSE HANDLING
   ==================================================================== */
function handleMatlabResponse(data) {
    if (!data || !data.response) return;
    if (data.timestamp !== undefined && data.timestamp <= lastTimestamp) return;
    lastTimestamp = data.timestamp;
    var payload = data.payload || {};

    if (payload.statusMessage) {
        setStatus(payload.statusType || 'success', payload.statusMessage);
    }

    switch (data.response) {
        case 'dataLoaded': onDataLoaded(payload); break;
        case 'spectrumLoaded': onSpectrumLoaded(payload); break;
        case 'previewUpdated': onPreviewUpdated(payload); break;
        case 'correctionProgress': updateProgress(payload.current, payload.total); break;
        case 'correctionApplied': onCorrectionApplied(payload); break;
        case 'intervalsLoaded': onIntervalsLoaded(payload); break;
        case 'showVarList': showVariableSelectionModal(payload); break;
        case 'showTableList': showTableSelectionModal(payload); break;
        case 'showExportDialog': showExportModal(payload); break;
        case 'exportCompleted': onExportCompleted(payload); break;
        case 'showImportDialog': showImportModal(payload); break;
        case 'paramsImported': applyImportedParams(payload); break;
        case 'statusUpdate':
            if (payload.type === 'error') hideProgressOverlay();
            setStatus(payload.type, payload.message);
            break;
    }
}

var exportCompleted = false;
function onExportCompleted(p) {
    var names = p.exportedNames || [];
    showToast('success', 'Export Complete', 'Exported to workspace: ' + names.join(', '));
    setStatus('success', 'Exported: ' + names.join(', '));
    exportCompleted = true;
}

function onDataLoaded(p) {
    wavelength = toArray(p.wavelength);
    meanSpectrum = toArray(p.meanSpectrum);
    currentSpectrum = meanSpectrum.slice();
    nSamples = p.nSamples || 0;
    nChannels = p.nChannels || 0;
    baselineData = [];
    correctedPreview = [];
    allCorrectedData = [];
    intervals = [];
    selectedIdx = -1;
    peaksEnabled = false; peaks = []; currentPeak = -1;
    previewView = null; correctedView = null;
    signalMode = false; currentSignal = 1; perSignalMode = false;
    perSignalIntervals = {}; perSignalGlobalParams = {};
    showAllSpectra = false;

    if (p.allSpectra) {
        allSpectra = [];
        var raw = p.allSpectra;
        if (Array.isArray(raw)) { for (var i = 0; i < raw.length; i++) allSpectra.push(toArray(raw[i])); }
        else { var ks = Object.keys(raw); for (var i = 0; i < ks.length; i++) allSpectra.push(toArray(raw[ks[i]])); }
    } else {
        allSpectra = [];
    }


    /* Enable controls */
    document.getElementById('btn-draw-interval').disabled = false;

    /* Hide peak section */
    document.getElementById('peak-section').style.display = 'none';

    updateBurgerChecks();
    updateSignalNav();
    updateSelectedIntervalPanel();
    updateIntervalTable();
    updateLegendSwatches();
    renderAll();
    scheduleAutoPreview();

    // Big data warning
    var totalCells = nSamples * nChannels;
    if (totalCells > 25000000) {
        showToast('warning', 'Large Dataset',
            nSamples + ' x ' + nChannels + ' = ' + (totalCells / 1e6).toFixed(1) + 'M cells. ' +
            'Showing all spectra simultaneously may be slow. Consider using signal-by-signal mode.', 8000);
    }
}

function onSpectrumLoaded(p) {
    currentSpectrum = toArray(p.spectrum);
    currentSignal = p.signalIndex || currentSignal;
    previewView = null;
    baselineData = [];
    correctedPreview = [];

    // If peak detection mode is active, re-detect peaks and recreate intervals for this signal
    if (peakNavMode) {
        detectPeaks();
        autoCreateIntervalsFromPeaks();
        if (peaks.length > 0) {
            currentPeak = 0;
            updatePeakLabel();
        }
    }

    renderAll();
    scheduleAutoPreview();
}

function onPreviewUpdated(p) {
    baselineData = toArray(p.baseline);
    correctedPreview = toArray(p.corrected);
    computeIntervalMetrics();
    updateIntervalTable();
    previewView = previewView;
    correctedView = null;
    renderAll();
}

function onCorrectionApplied(p) {
    hideProgressOverlay();
    correctedPreview = toArray(p.correctedMean);
    if (p.allCorrected) {
        allCorrectedData = [];
        var raw = p.allCorrected;
        if (Array.isArray(raw)) { for (var i = 0; i < raw.length; i++) allCorrectedData.push(toArray(raw[i])); }
        else { var ks = Object.keys(raw); for (var i = 0; i < ks.length; i++) allCorrectedData.push(toArray(raw[ks[i]])); }
    }
    correctedView = null;
    renderAll();
    showToast('success', 'Correction Complete', p.nCorrected + ' spectra have been corrected successfully.');
}

function onIntervalsLoaded(p) {
    var raw = p.intervals || [];
    var arr = [];
    if (Array.isArray(raw)) { arr = raw; }
    else { var ks = Object.keys(raw); for (var i = 0; i < ks.length; i++) arr.push(raw[ks[i]]); }

    if (p.perSignalFormat) {
        if (!perSignalMode) {
            perSignalMode = true;
            onPerSignalChanged();
        }
        for (var s = 1; s <= nSamples; s++) {
            perSignalIntervals[s] = [];
            perSignalGlobalParams[s] = getGlobalParams();
        }
        for (var i = 0; i < arr.length; i++) {
            var intv = arr[i];
            var si = intv.signalIndex || 1;
            if (!perSignalIntervals[si]) perSignalIntervals[si] = [];
            perSignalIntervals[si].push({ startIdx: intv.startIdx, endIdx: intv.endIdx, lambda: intv.lambda, p: intv.p });
            if (perSignalIntervals[si].length === 1 && intv.lambdaOut !== undefined) {
                perSignalGlobalParams[si] = { lambda: intv.lambdaOut, p: intv.pOut || 0.5, mu: intv.mu || 10 };
            }
        }
        loadCurrentSignalParams();
    } else {
        intervals = [];
        for (var i = 0; i < arr.length; i++) {
            intervals.push({ startIdx: arr[i].startIdx, endIdx: arr[i].endIdx, lambda: arr[i].lambda, p: arr[i].p });
        }
        selectedIdx = intervals.length > 0 ? 0 : -1;
    }
    updateBurgerChecks();
    updateSelectedIntervalPanel();
    updateIntervalTable();
    renderAll();
    scheduleAutoPreview();
}

function setStatus(type, message) {
    var ind = document.getElementById('status-indicator');
    document.getElementById('status-message').textContent = message || '';
    ind.className = 'status-indicator';
    if (type === 'error') {
        ind.classList.add('error');
        hideProgressOverlay(); // Always hide overlay on error
    }
    else if (type === 'processing' || type === 'loading') ind.classList.add('processing');
}

/* ====================================================================
   UTILITY
   ==================================================================== */
function toArray(obj) {
    if (Array.isArray(obj)) return obj;
    if (!obj) return [];
    var arr = [], keys = Object.keys(obj);
    for (var i = 0; i < keys.length; i++) arr.push(obj[keys[i]]);
    return arr;
}

/* ====================================================================
   SETUP + POLLING
   ==================================================================== */
function setup(component) {
    htmlComponent = component;
    component.addEventListener('DataChanged', function() { handleMatlabResponse(component.Data); });
    setInterval(function() {
        if (htmlComponent && htmlComponent.Data) handleMatlabResponse(htmlComponent.Data);
    }, 150);
    updateLegendSwatches();
    renderAll();
    setStatus('success', 'Interface ready - setup complete');
}

var resizeTimeout = null;
window.addEventListener('resize', function() {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(function() { renderAll(); }, 150);
});

/* ====================================================================
   SHOWCASE / TUTORIAL MODE
   ==================================================================== */
var showcaseActive = false;
var showcaseStep = 0;
var showcaseOverlay = null;
var showcaseHighlight = null;
var showcaseTooltip = null;
var showcaseTargetEl = null;

var showcaseSteps = [
    {
        type: 'welcome',
        title: 'Welcome to LASLS!',
        text: '<b>LASLS</b> (Locally Adaptive Smoothing Least Squares) is a powerful tool for <b>baseline correction</b> of spectroscopic data.<br><br>Baseline drift is a common problem in spectroscopy that can distort your measurements. This tutorial will guide you through the complete workflow to remove baselines from your spectra.'
    },
    {
        target: '#btn-load',
        title: 'Load Data',
        text: 'We have created demo spectral data called <b>"tutorialData"</b> in your MATLAB workspace. This sample contains synthetic spectra with baseline drift for you to practice with.<br><br><b>&#10148; Click the Load button</b> to open the variable selector and import this data.',
        position: 'right',
        action: 'click'
    },
    {
        type: 'right-center',
        title: 'Select Variable',
        text: 'A MATLAB dialog has appeared. This lets you choose which variable from your workspace contains your spectral data.<br><br><b>To continue:</b><br>1. Find and select <b>"tutorialData"</b> in the list<br>2. Click <b>OK</b> to load it',
        action: 'waitForData'
    },
    {
        target: '#preview-canvas',
        title: 'Preview Chart',
        text: 'This chart displays your spectral data. The <b style="color:#4A90D9">blue line</b> shows your original spectrum, while the <b style="color:#E74C3C">red line</b> shows the estimated baseline that will be subtracted.<br><br><b>Navigation tips:</b><br>&#8226; <b>Scroll</b> the mouse wheel to zoom in/out<br>&#8226; <b>Click and drag</b> to pan across the spectrum<br>&#8226; Use the icon badges above the chart for view controls and signal navigation',
        position: 'left-top'
    },
    {
        target: '#btn-draw-interval',
        title: 'Enter Draw Mode',
        text: 'Before correction, you need to mark the <b>spectral peaks</b> (regions of interest) that should be preserved. Drawing mode allows you to select these regions by clicking and dragging on the chart.<br><br><b>&#10148; Click this button</b> to activate Drawing Mode.',
        position: 'left-upper-low',
        action: 'click'
    },
    {
        target: '#preview-canvas',
        title: 'Draw an Interval',
        text: 'Now mark a peak region! <b>Intervals</b> tell the algorithm which areas contain actual spectral signals vs. baseline.<br><br><b>&#10148; Click and drag</b> horizontally across any peak you see in the spectrum. A highlighted region will appear showing your selection.<br><br><i>The algorithm will preserve signal in these marked regions while fitting the baseline to the unmarked areas.</i>',
        position: 'left-top',
        action: 'draw'
    },
    {
        target: '#badge-detect-peaks',
        title: 'Detect Peaks',
        text: 'Drawing intervals manually can be tedious. The <b>auto-detection</b> feature uses an algorithm to automatically find and mark all significant peaks in your spectrum.<br><br><b>&#10148; Click Detect Peaks</b> to automatically identify remaining peaks. You can always edit or delete detected intervals afterward.',
        position: 'bottom',
        action: 'click'
    },
    {
        target: '.intervals-table',
        title: 'Interval Table',
        text: 'This table lists all your marked intervals with their <b>start</b> and <b>end</b> positions. Each interval represents a peak region that will be preserved during baseline correction.<br><br><b>You can:</b><br>&#8226; Click a row to select and highlight that interval<br>&#8226; Double-click to edit interval boundaries<br>&#8226; Use the delete button to remove unwanted intervals',
        position: 'center-lower'
    },
    {
        target: '.intervals-table',
        title: 'Select an Interval',
        text: 'Before adjusting the baseline parameters, you need to select an interval to work with.<br><br><b>&#10148; Click on any row</b> in the table, or <b>click directly on a drawn interval</b> in the preview chart. The selected interval will be highlighted.',
        position: 'left-top',
        action: 'selectInterval'
    },
    {
        target: '#tab-global',
        title: 'Adjust Parameters',
        text: '<b>Adjust the baseline parameters:</b><br><br><b>&#955; (Lambda)</b> - Controls <b>smoothness</b>:<br>&#8226; Higher = smoother baseline<br>&#8226; Lower = more flexible baseline<br><br><b>p (Asymmetry)</b> - Controls how baseline treats peaks:<br>&#8226; Lower p (e.g., 0.001) = baseline stays below peaks<br>&#8226; Higher p = more symmetric fit<br><br><b>&#10148; Try adjusting both sliders</b> and observe how the red baseline changes in the preview.',
        position: 'right-lower'
    },
    {
        target: '#btn-apply',
        title: 'Apply Correction',
        text: 'Once you are satisfied with the baseline fit on the preview, apply the correction to <b>all spectra</b> in your dataset.<br><br>This will subtract the estimated baseline from each spectrum, leaving only the pure spectral signals.<br><br><b>&#10148; Click Apply</b> to process all your data with the current settings.',
        position: 'right',
        action: 'click'
    },
    {
        target: '#corrected-canvas',
        title: 'Corrected Result',
        text: 'This chart shows your <b>baseline-corrected spectra</b>. Notice how the baseline drift has been removed - the spectra now have a flat baseline around zero.<br><br>You can navigate through different samples using the controls, and compare the before/after results to verify the correction quality.',
        position: 'left-top'
    },
    {
        target: 'button[onclick="exportData()"]',
        title: 'Export',
        text: 'Finally, save your corrected data back to the MATLAB workspace for further analysis.<br><br>The export will create new variables containing:<br>&#8226; The corrected spectra matrix<br>&#8226; The estimated baselines<br><br><b>&#10148; Click Export</b> and complete the export dialog to save your results.',
        position: 'right',
        action: 'waitForExport'
    },
    {
        type: 'welcome',
        title: 'Tutorial Complete!',
        text: '<b>Congratulations!</b> You have mastered the LASLS workflow!<br><br><b>What you learned:</b> Load data &#8226; Draw/detect intervals &#8226; Adjust &#955; and P &#8226; Apply and Export<br><br><b>More features:</b><br>&#8226; <b>Sample navigation:</b> Browse sample-by-sample with the arrow badges<br>&#8226; <b>Per-interval parameters:</b> Fine-tune &#955; and P per region<br>&#8226; <b>Edit intervals:</b> Double-click rows or drag edges on chart<br>&#8226; <b>Zoom/pan:</b> Scroll to zoom, drag to pan<br><br><b>+</b> <b>Menu:</b> Click the <b>+</b> badge above the preview chart for more options: display settings, peak detection, solver, dark mode, and this tutorial.<br><br>Enjoy experimenting with your data!'
    }
];

function startShowcase() {
    try {
        if (showcaseActive) return;
        showcaseActive = true;
        document.getElementById('btn-tutorial').disabled = true;
        showcaseStep = 0;

        // Generate demo data in MATLAB workspace
        generateDemoData();
        showShowcaseStep();
    } catch (e) {
        console.error('Showcase error:', e);
    }
}

function generateDemoData() {
    // Create synthetic spectral data with peaks and baseline
    // Send to MATLAB workspace so user can practice loading it
    var numCh = 500;
    var numSamp = 10;

    var demoWavelength = [];
    var demoSpectra = [];

    for (var i = 0; i < numCh; i++) {
        demoWavelength.push(400 + i * 0.8); // 400-800 nm range
    }

    for (var s = 0; s < numSamp; s++) {
        var spectrum = [];
        for (var i = 0; i < numCh; i++) {
            // Curved baseline
            var bl = 100 + 50 * Math.sin(i / numCh * Math.PI) + 20 * Math.pow(i / numCh, 2);

            // Add some peaks
            var peak1 = 80 * Math.exp(-Math.pow((i - 120) / 15, 2));
            var peak2 = 120 * Math.exp(-Math.pow((i - 250) / 20, 2));
            var peak3 = 60 * Math.exp(-Math.pow((i - 380) / 12, 2));

            // Add noise and sample variation
            var noise = (Math.random() - 0.5) * 5;
            var sampleVar = (s / numSamp) * 20;

            spectrum.push(bl + peak1 + peak2 + peak3 + noise + sampleVar);
        }
        demoSpectra.push(spectrum);
    }

    // Send to MATLAB workspace
    sendAction('createDemoData', {
        spectra: demoSpectra,
        wavelength: demoWavelength
    });

    setStatus('success', 'Demo data created in workspace as "tutorialData"');
}

function endShowcase() {
    showcaseActive = false;
    document.getElementById('btn-tutorial').disabled = false;
    if (showcaseOverlay) { showcaseOverlay.remove(); showcaseOverlay = null; }
    if (showcaseHighlight) { showcaseHighlight.remove(); showcaseHighlight = null; }
    if (showcaseTooltip) { showcaseTooltip.remove(); showcaseTooltip = null; }
    if (showcaseTargetEl) {
        if (showcaseTargetEl._showcaseHandler) {
            showcaseTargetEl.removeEventListener('click', showcaseTargetEl._showcaseHandler);
            showcaseTargetEl.removeEventListener('input', showcaseTargetEl._showcaseHandler);
            showcaseTargetEl.removeEventListener('showcaseEvent', showcaseTargetEl._showcaseHandler);
            showcaseTargetEl._showcaseHandler = null;
        }
        if (showcaseTargetEl._intervalCheck) {
            clearInterval(showcaseTargetEl._intervalCheck);
            showcaseTargetEl._intervalCheck = null;
        }
        showcaseTargetEl = null;
    }
    setStatus('idle', 'Tutorial ended');
}

function nextShowcaseStep() {
    showcaseStep++;
    if (showcaseStep >= showcaseSteps.length) {
        endShowcase();
        return;
    }
    showShowcaseStep();
}


function showShowcaseStep() {
    try {
    var step = showcaseSteps[showcaseStep];

    // Remove old elements and cleanup
    if (showcaseOverlay) { showcaseOverlay.remove(); showcaseOverlay = null; }
    if (showcaseHighlight) { showcaseHighlight.remove(); showcaseHighlight = null; }
    if (showcaseTooltip) { showcaseTooltip.remove(); showcaseTooltip = null; }
    if (showcaseTargetEl) {
        if (showcaseTargetEl._showcaseHandler) {
            showcaseTargetEl.removeEventListener('click', showcaseTargetEl._showcaseHandler);
            showcaseTargetEl.removeEventListener('input', showcaseTargetEl._showcaseHandler);
            showcaseTargetEl.removeEventListener('showcaseEvent', showcaseTargetEl._showcaseHandler);
            showcaseTargetEl._showcaseHandler = null;
        }
        if (showcaseTargetEl._intervalCheck) {
            clearInterval(showcaseTargetEl._intervalCheck);
            showcaseTargetEl._intervalCheck = null;
        }
        showcaseTargetEl = null;
    }

    // Create overlay (blocks clicks on everything except highlighted element)
    // Skip overlay for: waitForData, draw, change, and steps with no action
    var needsOverlay = step.action === 'click';
    if (needsOverlay) {
        showcaseOverlay = document.createElement('div');
        showcaseOverlay.className = 'showcase-overlay';
        document.body.appendChild(showcaseOverlay);
    }

    // Create tooltip
    showcaseTooltip = document.createElement('div');
    showcaseTooltip.className = 'showcase-tooltip' + (showcaseStep === showcaseSteps.length - 1 ? ' showcase-final' : '');

    // Progress dots
    var progressHtml = '<div class="showcase-progress">';
    for (var i = 0; i < showcaseSteps.length; i++) {
        var dotClass = 'showcase-dot';
        if (i < showcaseStep) dotClass += ' done';
        else if (i === showcaseStep) dotClass += ' active';
        progressHtml += '<div class="' + dotClass + '"></div>';
    }
    progressHtml += '</div>';

    var html = progressHtml;
    html += '<div class="showcase-step">Step ' + (showcaseStep + 1) + ' of ' + showcaseSteps.length + '</div>';

    if (step.type === 'welcome' || step.type === 'modal' || step.type === 'corner') {
        html += '<div class="showcase-welcome">';
        if (step.icon) html += '<div class="showcase-icon">' + step.icon + '</div>';
        html += '<div class="showcase-title">' + step.title + '</div>';
        html += '<div class="showcase-text">' + step.text + '</div>';
        html += '</div>';
    } else {
        html += '<div class="showcase-title">' + step.title + '</div>';
        html += '<div class="showcase-text">' + step.text + '</div>';
    }

    // Close button in top right corner
    html += '<button class="showcase-close" onclick="endShowcase()" title="Close tutorial">&#10005;</button>';

    html += '<div class="showcase-btns">';
    // Hide Next button for steps that require user action (click, draw, change, waitForData, selectInterval, waitForExport)
    var requiresAction = step.action === 'click' || step.action === 'draw' || step.action === 'change' || step.action === 'waitForData' || step.action === 'selectInterval' || step.action === 'waitForExport';
    if (!requiresAction) {
        html += '<button class="showcase-btn showcase-btn-primary" onclick="nextShowcaseStep()">' +
                (showcaseStep === showcaseSteps.length - 1 ? 'Finish &#10003;' : 'Next &#8594;') + '</button>';
    }
    html += '</div>';

    showcaseTooltip.innerHTML = html;

    // Set position BEFORE adding to DOM to prevent flicker
    if (step.type === 'welcome' || step.type === 'modal') {
        // Center the tooltip for welcome/modal screens
        showcaseTooltip.style.left = '50%';
        showcaseTooltip.style.top = '50%';
        showcaseTooltip.style.transform = 'translate(-50%, -50%)';
    } else if (step.type === 'corner') {
        // Position in bottom right corner so it doesn't block MATLAB popups
        showcaseTooltip.style.right = '20px';
        showcaseTooltip.style.bottom = '20px';
        showcaseTooltip.style.left = 'auto';
        showcaseTooltip.style.top = 'auto';
    } else if (step.type === 'right-center') {
        // Position on the right side, vertically centered
        showcaseTooltip.style.right = '20px';
        showcaseTooltip.style.top = '50%';
        showcaseTooltip.style.transform = 'translateY(-50%)';
        showcaseTooltip.style.left = 'auto';
        showcaseTooltip.style.bottom = 'auto';
    }

    document.body.appendChild(showcaseTooltip);

    // Handle waitForData action - poll until NEW data is loaded
    if (step.action === 'waitForData') {
        var initialDataLength = allSpectra ? allSpectra.length : 0;
        showcaseTargetEl = { _intervalCheck: null };
        showcaseTargetEl._intervalCheck = setInterval(function() {
            var currentLength = allSpectra ? allSpectra.length : 0;
            // Advance only if data length changed (new data loaded)
            if (currentLength > 0 && currentLength !== initialDataLength) {
                clearInterval(showcaseTargetEl._intervalCheck);
                setTimeout(nextShowcaseStep, 300);
            }
        }, 300);
        return; // Don't continue to target highlighting
    }

    if (step.type !== 'welcome' && step.type !== 'modal' && step.type !== 'corner') {
        // Find and highlight target element
        var target = document.querySelector(step.target);
        if (!target) {
            nextShowcaseStep();
            return;
        }

        var rect = target.getBoundingClientRect();

        // Create highlight container that shows the actual element
        showcaseHighlight = document.createElement('div');
        showcaseHighlight.className = 'showcase-highlight-clone';
        showcaseHighlight.style.left = (rect.left - 6) + 'px';
        showcaseHighlight.style.top = (rect.top - 6) + 'px';
        showcaseHighlight.style.width = (rect.width + 12) + 'px';
        showcaseHighlight.style.height = (rect.height + 12) + 'px';

        // Clone the target element into the highlight
        var clone = target.cloneNode(true);
        clone.style.cssText = 'position:absolute;left:6px;top:6px;width:' + rect.width + 'px;height:' + rect.height + 'px;margin:0;';
        showcaseHighlight.appendChild(clone);

        // Handle different action types
        if (step.action === 'click') {
            var hint = document.createElement('div');
            hint.className = 'showcase-click-hint';
            hint.textContent = 'Click!';
            showcaseHighlight.appendChild(hint);

            var clickHandled = false;
            var handleClick = function() {
                if (clickHandled) return;
                clickHandled = true;
                setTimeout(nextShowcaseStep, 300);
            };

            // Make highlight clickable
            showcaseHighlight.onclick = function() {
                target.click();
                handleClick();
            };

            // Also listen on original target (in case user clicks it directly)
            showcaseTargetEl = target;
            target._showcaseHandler = handleClick;
            target.addEventListener('click', target._showcaseHandler);
        } else if (step.action === 'draw') {
            var hint = document.createElement('div');
            hint.className = 'showcase-click-hint';
            hint.textContent = 'Draw!';
            showcaseHighlight.appendChild(hint);

            // Allow interaction with the canvas
            showcaseHighlight.style.pointerEvents = 'none';

            // Listen for interval creation
            showcaseTargetEl = document;
            document._showcaseHandler = function(e) {
                if (e.detail && e.detail.type === 'intervalCreated') {
                    setTimeout(nextShowcaseStep, 300);
                }
            };
            document.addEventListener('showcaseEvent', document._showcaseHandler);

            // Also advance if intervals array grows
            var initialIntervals = intervals.length;
            showcaseTargetEl._intervalCheck = setInterval(function() {
                if (intervals.length > initialIntervals) {
                    clearInterval(showcaseTargetEl._intervalCheck);
                    setTimeout(nextShowcaseStep, 300);
                }
            }, 200);
        } else if (step.action === 'change') {
            var hint = document.createElement('div');
            hint.className = 'showcase-click-hint';
            hint.textContent = 'Adjust!';
            showcaseHighlight.appendChild(hint);

            // Allow interaction with the slider
            showcaseHighlight.style.pointerEvents = 'none';

            // Listen for slider value change - poll the value instead of relying on events
            showcaseTargetEl = { _intervalCheck: null };
            var initialValue = target.value;
            showcaseTargetEl._intervalCheck = setInterval(function() {
                if (target.value !== initialValue) {
                    clearInterval(showcaseTargetEl._intervalCheck);
                    // Show Next button in the tooltip
                    var btnsDiv = showcaseTooltip.querySelector('.showcase-btns');
                    if (btnsDiv && !btnsDiv.querySelector('.showcase-btn-primary')) {
                        var nextBtn = document.createElement('button');
                        nextBtn.className = 'showcase-btn showcase-btn-primary';
                        nextBtn.innerHTML = 'Next &#8594;';
                        nextBtn.onclick = nextShowcaseStep;
                        btnsDiv.appendChild(nextBtn);
                    }
                }
            }, 200);
        } else if (step.action === 'selectInterval') {
            var hint = document.createElement('div');
            hint.className = 'showcase-click-hint';
            hint.textContent = 'Click a row!';
            showcaseHighlight.appendChild(hint);

            // Allow interaction with the table
            showcaseHighlight.style.pointerEvents = 'none';

            // Listen for interval selection (selectedIdx change)
            showcaseTargetEl = { _intervalCheck: null };
            var initialSelection = selectedIdx;
            showcaseTargetEl._intervalCheck = setInterval(function() {
                if (selectedIdx !== initialSelection && selectedIdx >= 0) {
                    clearInterval(showcaseTargetEl._intervalCheck);
                    setTimeout(nextShowcaseStep, 300);
                }
            }, 200);
        } else if (step.action === 'waitForExport') {
            var hint = document.createElement('div');
            hint.className = 'showcase-click-hint';
            hint.textContent = 'Export!';
            showcaseHighlight.appendChild(hint);

            // Allow interaction with the button
            showcaseHighlight.style.pointerEvents = 'none';

            // Reset export flag and wait for export completion
            exportCompleted = false;
            showcaseTargetEl = { _intervalCheck: null };
            showcaseTargetEl._intervalCheck = setInterval(function() {
                if (exportCompleted) {
                    clearInterval(showcaseTargetEl._intervalCheck);
                    setTimeout(nextShowcaseStep, 500);
                }
            }, 200);
        } else {
            showcaseHighlight.style.pointerEvents = 'none';
        }

        document.body.appendChild(showcaseHighlight);

        // Position tooltip relative to target using step.position
        var ttWidth = 320;
        var ttHeight = 180;
        var margin = 15;
        var ttLeft, ttTop;
        var pos = step.position || 'right';

        if (pos === 'center') {
            // Center the tooltip on screen
            showcaseTooltip.style.left = '50%';
            showcaseTooltip.style.top = '50%';
            showcaseTooltip.style.transform = 'translate(-50%, -50%)';
        } else if (pos === 'center-lower') {
            // Center horizontally, slightly below center vertically
            showcaseTooltip.style.left = '50%';
            showcaseTooltip.style.top = '65%';
            showcaseTooltip.style.transform = 'translate(-50%, -50%)';
            showcaseTooltip.style.bottom = 'auto';
            showcaseTooltip.style.right = 'auto';
        } else if (pos === 'corner-left-bottom') {
            // Position in left bottom corner
            showcaseTooltip.style.left = '20px';
            showcaseTooltip.style.bottom = '20px';
            showcaseTooltip.style.top = 'auto';
            showcaseTooltip.style.right = 'auto';
            showcaseTooltip.style.transform = 'none';
        } else if (pos === 'left-top') {
            // Position on left side, near top
            showcaseTooltip.style.left = '20px';
            showcaseTooltip.style.top = '130px';
            showcaseTooltip.style.bottom = 'auto';
            showcaseTooltip.style.right = 'auto';
            showcaseTooltip.style.transform = 'none';
        } else if (pos === 'left-upper') {
            // Position on left side, slightly below top
            showcaseTooltip.style.left = '20px';
            showcaseTooltip.style.top = '200px';
            showcaseTooltip.style.bottom = 'auto';
            showcaseTooltip.style.right = 'auto';
            showcaseTooltip.style.transform = 'none';
        } else if (pos === 'left-upper-low') {
            // Position on left side, a bit lower than left-upper
            showcaseTooltip.style.left = '20px';
            showcaseTooltip.style.top = '280px';
            showcaseTooltip.style.bottom = 'auto';
            showcaseTooltip.style.right = 'auto';
            showcaseTooltip.style.transform = 'none';
        } else if (pos === 'left-lower') {
            // Position on left side, slightly below center
            showcaseTooltip.style.left = '20px';
            showcaseTooltip.style.top = '60%';
            showcaseTooltip.style.bottom = 'auto';
            showcaseTooltip.style.right = 'auto';
            showcaseTooltip.style.transform = 'translateY(-50%)';
        } else if (pos === 'left-center') {
            // Position on left side, slightly above center (for step 11)
            showcaseTooltip.style.left = '20px';
            showcaseTooltip.style.top = '40%';
            showcaseTooltip.style.bottom = 'auto';
            showcaseTooltip.style.right = 'auto';
            showcaseTooltip.style.transform = 'translateY(-50%)';
        } else if (pos === 'corner-right-bottom') {
            // Position in right bottom corner
            showcaseTooltip.style.right = '20px';
            showcaseTooltip.style.bottom = '20px';
            showcaseTooltip.style.top = 'auto';
            showcaseTooltip.style.left = 'auto';
            showcaseTooltip.style.transform = 'none';
        } else if (pos === 'right-lower') {
            // Position on right side, slightly below center (for step 10)
            showcaseTooltip.style.right = '20px';
            showcaseTooltip.style.bottom = '120px';
            showcaseTooltip.style.top = 'auto';
            showcaseTooltip.style.left = 'auto';
            showcaseTooltip.style.transform = 'none';
        } else {
            if (pos === 'right') {
                ttLeft = rect.right + margin;
                ttTop = Math.max(10, Math.min(window.innerHeight - ttHeight - 10, rect.top));
            } else if (pos === 'left') {
                ttLeft = rect.left - ttWidth - margin;
                ttTop = Math.max(10, Math.min(window.innerHeight - ttHeight - 10, rect.top));
            } else if (pos === 'bottom') {
                ttLeft = Math.max(10, Math.min(window.innerWidth - ttWidth - 10, rect.left));
                ttTop = rect.bottom + margin;
            } else if (pos === 'top') {
                ttLeft = Math.max(10, Math.min(window.innerWidth - ttWidth - 10, rect.left));
                ttTop = Math.max(10, rect.top - ttHeight - margin);
            }

            // Ensure tooltip stays on screen
            ttLeft = Math.max(10, Math.min(window.innerWidth - ttWidth - 10, ttLeft));
            ttTop = Math.max(10, Math.min(window.innerHeight - ttHeight - 10, ttTop));

            showcaseTooltip.style.left = ttLeft + 'px';
            showcaseTooltip.style.top = ttTop + 'px';
            showcaseTooltip.style.bottom = 'auto';
            showcaseTooltip.style.right = 'auto';
            showcaseTooltip.style.transform = 'none';
        }
    }
    } catch (e) {
        console.error('ShowcaseStep error:', e);
        endShowcase();
    }
}

// Keyboard navigation for showcase
document.addEventListener('keydown', function(e) {
    if (!showcaseActive) return;
    var step = showcaseSteps[showcaseStep];
    if (e.key === 'Escape') {
        endShowcase();
    } else if (e.key === 'ArrowRight' || e.key === 'Enter' || e.key === ' ') {
        // Only allow keyboard next if NOT an action step
        if (step && step.action !== 'click') {
            e.preventDefault();
            nextShowcaseStep();
        }
    }
});

</script>
</body>
</html>
